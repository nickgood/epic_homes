---
title: "Sense Fraction In Use"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 16,
  cache = FALSE,
  eval = FALSE)

```

```{r source_functions_libraries, eval = TRUE}
# reads source
source("../functions_epic.R")
# add extra libraries for cluster analysis
library('cluster')
library('factoextra')


```

```{r data_import, eval = TRUE}
data <- read_rds("../output/sense_all.rds")
```

---

# Home 001 Device Fraction On

## Hourly

```{r}
home_001 <- data %>%
  filter(job_id == "001")
```

```{r}
home_001_f <- home_001 %>%
  mutate(hod = hour(datetime),
         sense_device_name = if_else(is.na(sense_device_name), device_id, sense_device_name)) %>%
  group_by(sense_device_name, hod) %>%
  summarise(start = min(datetime),
            end = max(datetime),
            mins = n(),
            .groups = "drop") %>%
  mutate(d_min =  as.numeric(end - start)  / (60 * 24),
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct))

```

```{r, fig.width=10, fig.height=16}


ggplot(home_001_f, aes(x = hod, y = pct) ) +
    geom_segment(aes(x = hod, xend = hod, y = 0, yend = pct), color = "grey") +
    geom_point(size = 1, color="#69b3a2") +
    coord_flip() +
    theme_ipsum() +
    theme(panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      legend.position="none") +
    scale_x_continuous(breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24)) +
    xlab("Hour of Day") +
    ylab("Time in use (%)") +
    #scale_x_log10() +
  facet_wrap(~sense_device_name, ncol = 4, scales = "free")

```



---

# Daily Device Overviews  

## Fraction On  

```{r daily_frac_func, include = FALSE, eval = FALSE}

# function to test daily usage per device by home

daily.fraction <- function(home_id # home id, in form: '003'
                       ) {
a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
  summarise(
    mins = n(), # amount of minutes device was on during specified day
    .groups = "drop") %>%
  mutate(d_min =  60 * 24, # amoutn of minutes in each day
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct))

# plot for specified home
ggplot(a, aes(x = dateday, y = pct) ) +
geom_segment(aes(xend = dateday, y = 0, yend = pct)) +
    theme(panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      legend.position="none") +
coord_cartesian(ylim = c(0,100))+
  # scale_x_continuous(breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24)) +
    xlab("Date") +
    ylab("Time in use (%)") +
    #scale_x_log10() +
  facet_wrap(~sense_device_name, ncol = 4, scales = "fixed")+
  ggtitle(paste('Home', home_id, 'Fraction On'))
}


```

```{r daily_frac_overview, eval = FALSE}

# apply above function to all homes
lapply(levels(as.factor(data$job_id)), daily.fraction)
```


## Consumption  

```{r daily_consum_functions, include = FALSE, eval = FALSE}

# function to test daily usage per device by home

daily.consumption <- function(home_id # home id, in form: '003'
                       ) {
a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
  summarise(
    consumption = sum(consumption_kwh, na.rm = TRUE),
    .groups = "drop")

# plot for specified home
ggplot(a, aes(x = dateday, y = consumption) ) +
geom_segment(aes(xend = dateday, y = 0, yend = consumption)) +
    theme(panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      legend.position="none") +
# coord_cartesian(ylim = c(0,100))+
  # scale_x_continuous(breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24)) +
    xlab("Date") +
    ylab("Consumption (kwh)") +
    #scale_x_log10() +
  facet_wrap(~sense_device_name, ncol = 4, scales = "fixed")+
  ggtitle(paste('Home', home_id, 'Consumption'))
}


```

```{r daily_consum_overview, eval = FALSE}
# homes 3 and 16 do not have data available

# apply above function to all homes
lapply(levels(as.factor(data$job_id)), daily.consumption)
```


# Cluster days based on heating and ac behaviours  


```{r cluster_functions, include = FALSE, eval = FALSE}



cluster.maker <- function(home_id, # home id, in form: '003'
                       devices, # character vector of devices from which to make clusters
                       group_heat_ac = FALSE # if TRUE, group all devices of heat and ac together
                       ) {
  
  data <- if(group_heat_ac == TRUE) {
    
    data %>% 
      mutate(
    sense_device_name = case_when(
      # any string that starts with heat or furnace
       grepl('^heat*.', sense_device_name) |
      grepl('^furnace*.', sense_device_name) ~ 'heat',
      # any string that starts with ac
      grepl('^ac*.', sense_device_name) ~ 'ac',
      TRUE ~ sense_device_name))
    
  } else {data}
  
a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
 summarise(
    mins = n(), # amount of minutes device was on during specified day
    consumption = sum(consumption_kwh, na.rm = TRUE),
    .groups = "drop") %>%
  mutate(d_min =  60 * 24, # amoutn of minutes in each day
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct)) %>% # make cluster of time periods
  
    select(-c(mins,d_min))%>%
    pivot_wider(names_from = sense_device_name, values_from = c(pct, consumption),
                values_fill = 0 # make device usage minutes zero if not registered
                # in a certain day
    ) %>%
      select(dateday, ends_with(all_of(devices))) %>%
    tibble::column_to_rownames(var = 'dateday') %>%
    ##scale the data to prepare for cluster analysis
    scale()
}


# function to run multiple tests determining optimal cluster number
cluster.tests <- function(
  df, # dataframe resulting from cluster_maker function
  measure # what will be evaluated for the device? either 'pct' or 'consumption'
  ) {
  
  df <- df %>%
    as.data.frame() %>%
    select(starts_with(measure))
  
  #####decide how many clusters to use using different methods:
  #silhouette
  a <- fviz_nbclust(df, pam, method = 'silhouette')
  
  #knee bend
  b <- fviz_nbclust(df, pam, method = 'wss')
  
  
  # Gap statistic
  # nboot = 50 to keep the function speedy. 
  # recommended value: nboot= 500 for your analysis.
  # Use verbose = FALSE to hide computing progression.
  c<-  fviz_nbclust(df, kmeans, nstart = 25,  method = "gap_stat", nboot = 50)+
    labs(subtitle = "Gap statistic method")
  
  return(list(a,b,c))
}


# function to separate daily data into clusters and plot
cluster.plots <- function(
  home_id, # home id, in form: '003', just for labeling plot
  df, # dataframe resulting from cluster_maker function
  cluster_amount, # sepcifed amount of clusters
    measure # what will be evaluated for the device? either 'pct' or 'consumption'
  
) {
  
    df <- df %>%
    as.data.frame() %>%
    select(starts_with(measure))
  
  ###plot with decided number of clusters
  ##use pam package
  pam.res <- pam(df, cluster_amount)
  
  cluster_colors <- c('red', 'blue', 'darkgreen', 'darkorange', 'purple')
  
  # Visualize pam clustering if more than one device is used 
  pca_cluster_plot <- if(ncol(df)>1) {
    fviz_cluster(pam.res, geom = "point", ellipse = FALSE,
                                   palette = cluster_colors,
                 main = paste('Home', home_id, measure))
  } else {
    # if only one device was used, show average scaled values for each cluster
    df %>%
  as.data.frame() %>%
    ##add a cludter column to dataframe
    mutate(cluster = pam.res$clustering) %>%
  group_by(cluster) %>%
  summarise_all(mean, na.rm = TRUE) %>%
  ungroup()}
  
  #make function to define color based on cluster
  color.find <- function(x)  cluster_colors[x]
  
  df_clust <- df %>%
    as.data.frame() %>%
    ##add a cludter column to dataframe and put date back in as column
    mutate(cluster = pam.res$clustering) %>%
    mutate(clust_color = color.find(cluster)) %>% # add column for color based on cluster
    tibble::rownames_to_column(var = 'date')%>%
    #convert date column from character to date
    #and cluster to factor
    mutate(date = as.Date(date), cluster = as.factor(cluster))
  
  
  
  
  # #plot the cluster number over date to see if there is a
  # #"trend" or identification of fire time period
  # ggplot(df_clust, aes(x = date, y = cluster)) +
  #   geom_col(orientation = 'x')+
  #   scale_x_date(date_breaks = "1 month", date_labels = '%B')
  
  # map color column to cluster number column
  # from https://stackoverflow.com/questions/35279570/assign-point-color-depending-on-data-frame-column-value-r
  col <- as.character(df_clust$clust_color)
  names(col) <- as.character(df_clust$cluster)
  
  #plot the cluster number over date to see if there is a "trend"
  time_cluster_plot <- ggplot(df_clust, aes(x = date, y = 1)) +
    # color data point by cluster
    geom_tile(aes(fill = cluster))+
    scale_fill_manual(values = col)+
    scale_x_date(date_breaks = "1 month", date_labels = '%B')+
    theme_bw()+
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )+
    ggtitle(paste('Home', home_id, measure))
  
  return(list(pca_cluster_plot, time_cluster_plot))
}



```


```{r cluster_maker, eval = FALSE}

hm <- '001'
# 2 feasible ac units...
cluster_df_001 <- cluster.maker(hm, c('heat 6','ac'))




hm <- '002'
#
cluster_df_002 <- cluster.maker(hm, c('furnace','ac 2'))


hm <- '003'
# # home 3 not available?
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


hm <- '004'
# no AC
cluster_df_004 <- cluster.maker(hm, c('furnace'))


hm <- '006'
#
cluster_df_006 <- cluster.maker(hm, c('heat 1','ac'))

hm <- '007'
# 
cluster_df_007 <- cluster.maker(hm, c('heat 2','ac'))


hm <- '008'
# many heats that could be feasible...
# heat 1 and 2 on approx same fraction, but 2 consumes more energy
cluster_df_008 <- cluster.maker(hm, c('heat 2','ac'))


hm <- '009'
# many heats that could be feasible...
# consider summing consumption from heat 2 and 3 with furnace to cluster
cluster_df_009 <- cluster.maker(hm, c('furnace','ac'))


hm <- '010'
# no ac (later enrollment), also no one heat that makes complete sense by itself...
cluster_df_010 <- cluster.maker(hm, c('heat 2'))


hm <- '011'
# no ac (later enrollment)
cluster_df_011 <- cluster.maker(hm, c('heat 6'))


hm <- '012'
#
cluster_df_012 <- cluster.maker(hm, c('furnace','ac'))


hm <- '013'
# only 4 days of ac detected, so not used to cluster
# no heats consume much, but heat 2 is on most often/constently
cluster_df_013 <- cluster.maker(hm, c('heat 2'))


hm <- '014'
# heat doesn't look feasible...
# ac on at unexpected months
cluster_df_014 <- cluster.maker(hm, c('heat 1','ac'))


hm <- '015'
# on ac, multiple feasible heats
cluster_df_015 <- cluster.maker(hm, c('furnace'))


hm <- '016'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


hm <- '017'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))



```

## By Per-Device Fraction On

```{r cluster_plot_frac, eval = FALSE, fig.width=10, fig.height=3}

# make plots for all homes
hm <- '001'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')

hm <- '002'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')

hm <- '003'
# # home 3 not available?


hm <- '004'
# cluster.tests(get(paste0('cluster_df_', hm)), 'pct')
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'pct')


hm <- '006'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '007'
# 
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '008'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '009'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '010'
cluster.tests(get(paste0('cluster_df_', hm)), 'pct')
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'pct')


hm <- '011'
cluster.tests(get(paste0('cluster_df_', hm)), 'pct')
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'pct')


hm <- '012'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '013'
cluster.tests(get(paste0('cluster_df_', hm)), 'pct')
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'pct')


hm <- '014'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'pct')


hm <- '015'
cluster.tests(get(paste0('cluster_df_', hm)), 'pct')
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'pct')




```

## By Per-Device Consumption
```{r cluster_plot_consum, eval = FALSE, fig.width=10, fig.height=3}

# make plots for all homes
hm <- '001'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')

hm <- '002'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')

hm <- '003'
# # home 3 not available?


hm <- '004'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '006'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '007'
# 
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '008'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '009'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '010'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '011'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '012'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '013'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '014'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '015'
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')




```

## By Summed Heat/AC consumption
```{r cluster_maker_summed, eval = FALSE}

hm <- '001'
# 2 feasible ac units...
cluster_df_001 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)




hm <- '002'
#
cluster_df_002 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '003'
# # home 3 not available?
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


hm <- '004'
# no AC
cluster_df_004 <- cluster.maker(hm, c('heat'), group_heat_ac = TRUE)


hm <- '006'
#
cluster_df_006 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)

hm <- '007'
# 
cluster_df_007 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '008'
# many heats that could be feasible...
# heat 1 and 2 on approx same fraction, but 2 consumes more energy
cluster_df_008 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '009'
# many heats that could be feasible...
# consider summing consumption from heat 2 and 3 with furnace to cluster
cluster_df_009 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '010'
# no ac (later enrollment), also no one heat that makes complete sense by itself...
cluster_df_010 <- cluster.maker(hm, c('heat'), group_heat_ac = TRUE)


hm <- '011'
# no ac (later enrollment)
cluster_df_011 <- cluster.maker(hm, c('heat'), group_heat_ac = TRUE)


hm <- '012'
#
cluster_df_012 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '013'
# only 4 days of ac detected, so not used to cluster
# no heats consume much, but heat 2 is on most often/constently
cluster_df_013 <- cluster.maker(hm, c('heat'), group_heat_ac = TRUE)


hm <- '014'
# heat doesn't look feasible...
# ac on at unexpected months
cluster_df_014 <- cluster.maker(hm, c('heat','ac'), group_heat_ac = TRUE)


hm <- '015'
# on ac, multiple feasible heats
cluster_df_015 <- cluster.maker(hm, c('heat'), group_heat_ac = TRUE)


hm <- '016'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


hm <- '017'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))



```

```{r cluster_plot_consum_summed, eval = FALSE, fig.width=10, fig.height=3}

# make plots for all homes
hm <- '001'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')

hm <- '002'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')

hm <- '003'
# # home 3 not available?


hm <- '004'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '006'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '007'
# 
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '008'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '009'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '010'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '011'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '012'
#
cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '013'

cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')


hm <- '014'

cluster.plots(hm, get(paste0('cluster_df_', hm)),3, 'consumption')


hm <- '015'
cluster.plots(hm, get(paste0('cluster_df_', hm)),2, 'consumption')




```


# Compare Clustering Methods  
```{r cluster_compare, eval = TRUE, fig.width=10, fig.height=5}

# define variables
# just compare methods for daily fraction of time-on (pct)
measure <- 'pct'


cluster.methods <- function(home_id, devices) {

a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
 summarise(
    mins = n(), # amount of minutes device was on during specified day
    consumption = sum(consumption_kwh, na.rm = TRUE),
    .groups = "drop") %>%
  mutate(d_min =  60 * 24, # amoutn of minutes in each day
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct)) %>% # make cluster of time periods
  
    select(-c(mins,d_min))%>%
    pivot_wider(names_from = sense_device_name, values_from = c(pct, consumption),
                values_fill = 0 # make device usage minutes zero if not registered
                # in a certain day
    ) %>%
      select(dateday, ends_with(all_of(devices))) %>%
  select(dateday, starts_with(measure)) %>%
  #rename specific heat and ac columns to generic terms
  rename_at(vars(contains(c('heat', 'furnace'))), list(~sub('.*','heat',.))) %>%
  rename_at(vars(contains('ac')), list(~sub('.*','ac',.)))

# boxplot of unscaled daily device usage fraction
a_dev <- a %>%
  pivot_longer(cols = c(heat,ac), names_to = 'device', values_to = 'usage')

boxplot <- ggplot(a_dev, aes(y = usage))+
  geom_boxplot()+
  facet_wrap(vars(device))+
  ggtitle(home_id)



a <- a  %>%
  # add in scaled column for cluster making
  mutate_at(vars(-dateday), list(scaled = scale))


dist_mat <- dist(a %>% select(-c(dateday, heat, ac)))

# make cuts from different hierarchical methods
cut_avg <- cutree(hclust(dist_mat, method = 'average' ), k = 3)
cut_sing <- cutree(hclust(dist_mat, method = 'single'), k = 3)
cut_ward <- cutree(hclust(dist_mat, method = 'ward.D' ), k = 3)
cut_ward2 <- cutree(hclust(dist_mat, method = 'ward.D2'), k = 3)
cut_comp <- cutree(hclust(dist_mat, method = 'complete' ), k = 3)
cut_mcq <- cutree(hclust(dist_mat, method = 'mcquitty'), k = 3)
cut_cent <- cutree(hclust(dist_mat, method = 'centroid'), k = 3)


# make cluster color scale
cluster_colors <- c('red', 'blue', 'darkgreen')

#make function to define color based on cluster
color.find <- function(x)  cluster_colors[x]

# make a df with all clustering methods
a_cl <- a %>%
  # make level of use columns for heat and ac (unscaled)
  # heat based on quantile
  # ac based on value
  mutate(heat_use = if_else(heat>quantile(heat, 0.5), 'high', 'low'),
         ac_use = if_else(ac> 5, 'high', 'low')) %>%
  mutate(cluster_manual = case_when(
    heat_use == 'high' ~ 1,
    heat_use == 'low' & ac_use == 'high' ~ 2,
    heat_use == 'low' & ac_use == 'low' ~ 3
  )) %>%
  select(-c(heat_use, ac_use))%>%
  mutate(cluster_avg = cut_avg, cluster_sing = cut_sing, cluster_ward = cut_ward,
         cluster_ward2 = cut_ward2, cluster_comp = cut_comp, cluster_mcq = cut_mcq,
         cluster_cent = cut_cent) %>%
  pivot_longer(cols = c(cluster_avg,cluster_sing, cluster_ward, cluster_ward2,
                        cluster_comp, cluster_mcq, cluster_cent,
                        cluster_manual
                        ),
               names_to = 'cluster_method', values_to = 'cluster') %>%
  mutate(clust_color = color.find(cluster)) %>% # add column for color based on cluster
  #convert cluster col to factor
  mutate(cluster = as.factor(cluster))


cluster_point_plot <- 
  ggplot(a_cl, aes(x= heat_scaled, y = ac_scaled, color = factor(cluster)),
                 palette)+
  geom_point()+
  facet_wrap(vars(cluster_method))+
  scale_color_manual(values = cluster_colors)+
  ggtitle(home_id)




# map color column to cluster number column
# from https://stackoverflow.com/questions/35279570/assign-point-color-depending-on-data-frame-column-value-r
col <- as.character(a_cl$clust_color)
names(col) <- as.character(a_cl$cluster)

#plot the cluster number over date to see if there is a "trend"
cluster_time_plot <- ggplot(a_cl, aes(x = as.Date(dateday), y = 1)) +
  # color data point by cluster
  geom_tile(aes(fill = cluster))+
  scale_fill_manual(values = col)+
  scale_x_date(date_breaks = "1 month", date_labels = '%B')+
  theme_bw()+
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )+
  ggtitle(paste('Home', home_id, measure))+
  facet_wrap(vars(cluster_method))

return(list( boxplot, cluster_point_plot, cluster_time_plot))
}


###############################################################



hm <- '001'
# 2 feasible ac units...
cluster.methods(hm, c('heat 6','ac'))


hm <- '002'
#
cluster.methods(hm, c('furnace','ac 2'))


hm <- '003'
# # home 3 not available?
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


# hm <- '004'
# # no AC
# cluster.methods(hm, c('furnace'))


hm <- '006'
#
cluster.methods(hm, c('heat 1','ac'))

hm <- '007'
# 
cluster.methods(hm, c('heat 2','ac'))


hm <- '008'
# many heats that could be feasible...
# heat 1 and 2 on approx same fraction, but 2 consumes more energy
cluster.methods(hm, c('heat 2','ac'))


hm <- '009'
# many heats that could be feasible...
# consider summing consumption from heat 2 and 3 with furnace to cluster
cluster.methods(hm, c('furnace','ac'))


# hm <- '010'
# # no ac (later enrollment), also no one heat that makes complete sense by itself...
# cluster.methods(hm, c('heat 2'))


# hm <- '011'
# # no ac (later enrollment)
# cluster.methods(hm, c('heat 6'))


hm <- '012'
#
cluster.methods(hm, c('furnace','ac'))


# hm <- '013'
# # only 4 days of ac detected, so not used to cluster
# # no heats consume much, but heat 2 is on most often/constently
# cluster_df_013 <- cluster.maker(hm, c('heat 2'))


hm <- '014'
# heat doesn't look feasible...
# ac on at unexpected months
cluster.methods(hm, c('heat 1','ac'))


# hm <- '015'
# # on ac, multiple feasible heats
# cluster_df_015 <- cluster.maker(hm, c('furnace'))


hm <- '016'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))


hm <- '017'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))




```

