---
title: "Sense Fraction In Use"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 16,
  cache = FALSE,
  eval = FALSE)

```

```{r, eval = TRUE}
# reads source
source("../functions_epic.R")
# add extra libraries for cluster analysis
library('cluster')
library('factoextra')


```

```{r, eval = TRUE}
data <- read_rds("../output/sense_all.rds")
```

---

# Home 001 Device Fraction On

## Hourly

```{r}
home_001 <- data %>%
  filter(job_id == "001")
```

```{r}
home_001_f <- home_001 %>%
  mutate(hod = hour(datetime),
         sense_device_name = if_else(is.na(sense_device_name), device_id, sense_device_name)) %>%
  group_by(sense_device_name, hod) %>%
  summarise(start = min(datetime),
            end = max(datetime),
            mins = n(),
            .groups = "drop") %>%
  mutate(d_min =  as.numeric(end - start)  / (60 * 24),
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct))

```

```{r, fig.width=10, fig.height=16}


ggplot(home_001_f, aes(x = hod, y = pct) ) +
    geom_segment(aes(x = hod, xend = hod, y = 0, yend = pct), color = "grey") +
    geom_point(size = 1, color="#69b3a2") +
    coord_flip() +
    theme_ipsum() +
    theme(panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      legend.position="none") +
    scale_x_continuous(breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24)) +
    xlab("Hour of Day") +
    ylab("Time in use (%)") +
    #scale_x_log10() +
  facet_wrap(~sense_device_name, ncol = 4, scales = "free")

```




---

# Daily

```{r, include = FALSE, eval = FALSE}

# function to test daily usage per device by home

daily.usage <- function(home_id # home id, in form: '003'
                       ) {
a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
  summarise(
    mins = n(), # amount of minutes device was on during specified day
    .groups = "drop") %>%
  mutate(d_min =  60 * 24, # amoutn of minutes in each day
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct))

# plot for specified home
ggplot(a, aes(x = dateday, y = pct) ) +
geom_segment(aes(xend = dateday, y = 0, yend = pct)) +
    theme(panel.grid.minor.y = element_blank(),
      panel.grid.major.y = element_blank(),
      legend.position="none") +
coord_cartesian(ylim = c(0,100))+
  # scale_x_continuous(breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24)) +
    xlab("Date") +
    ylab("Time in use (%)") +
    #scale_x_log10() +
  facet_wrap(~sense_device_name, ncol = 4, scales = "free")+
  ggtitle(paste('Home', home_id))
}


```

```{r, eval = FALSE}

# apply above function to all homes
lapply(levels(as.factor(data$job_id)), daily.usage)
```


## Cluster days based on heating and ac behaviours  

## Compare all homes


```{r cluster_functions, include = FALSE, eval = TRUE}


cluster.maker <- function(home_id, # home id, in form: '003'
                       devices # character vector of devices from which to make clusters
                       ) {
a <- data %>%
  filter(job_id == home_id) %>%
  mutate(dateday = floor_date(datetime, unit = 'day'),
         sense_device_name = if_else(is.na(sense_device_name),
                                     device_id, sense_device_name)) %>%
  group_by(sense_device_name, dateday) %>%
  summarise(
    mins = n(), # amount of minutes device was on during specified day
    .groups = "drop") %>%
  mutate(d_min =  60 * 24, # amoutn of minutes in each day
         pct = mins * 100 / d_min,
         pct = if_else(pct == Inf, 0, pct),
         pct = if_else(d_min < 50, 0, pct)) %>%
  
  # make cluster of time periods
  
    select(-c(mins,d_min))%>%
    pivot_wider(names_from = sense_device_name, values_from = pct,
                values_fill = 0 # make device usage minutes zero if not registered
                # in a certain day
    ) %>%
    select(dateday, all_of(devices)) %>%
    tibble::column_to_rownames(var = 'dateday') %>%
    ##scale the data to prepare for cluster analysis
    scale()

}

# function to run multiple tests determining optimal cluster number
cluster.tests <- function(
  df # dataframe resulting from cluster_maker function
) {
  
  #####decide how many clusters to use using different methods:
  #silhouette
  a <- fviz_nbclust(df, pam, method = 'silhouette')
  
  #knee bend
  b <- fviz_nbclust(df, pam, method = 'wss')
  
  
  # Gap statistic
  # nboot = 50 to keep the function speedy. 
  # recommended value: nboot= 500 for your analysis.
  # Use verbose = FALSE to hide computing progression.
  c<-  fviz_nbclust(df, kmeans, nstart = 25,  method = "gap_stat", nboot = 50)+
    labs(subtitle = "Gap statistic method")
  
  return(list(a,b,c))
}


# function to separate daily data into clusters and plot
cluster.plots <- function(
  home_id, # home id, in form: '003', just for labeling plot
  df, # dataframe resulting from cluster_maker function
  cluster_amount # sepcifed amount of clusters
) {
  
  
  ###plot with decided number of clusters
  ##use pam package
  pam.res <- pam(df, cluster_amount)
  
  cluster_colors <- c('red', 'blue', 'darkgreen', 'darkorange', 'purple')
  
  # Visualize pam clustering if more than one device is used 
  pca_cluster_plot <- if(ncol(df)>1) {
    fviz_cluster(pam.res, geom = "point", ellipse = FALSE,
                                   palette = cluster_colors,
                 main = paste('Home', home_id))
  } else {NULL}
  
  #make function to define color based on cluster
  color.find <- function(x)  cluster_colors[x]
  
  df_clust <- df %>%
    as.data.frame() %>%
    ##add a cludter column to dataframe and put date back in as column
    mutate(cluster = pam.res$clustering) %>%
    mutate(clust_color = color.find(cluster)) %>% # add column for color based on cluster
    tibble::rownames_to_column(var = 'date')%>%
    #convert date column from character to date
    #and cluster to factor
    mutate(date = as.Date(date), cluster = as.factor(cluster))
  
  
  
  
  # #plot the cluster number over date to see if there is a
  # #"trend" or identification of fire time period
  # ggplot(df_clust, aes(x = date, y = cluster)) +
  #   geom_col(orientation = 'x')+
  #   scale_x_date(date_breaks = "1 month", date_labels = '%B')
  
  # map color column to cluster number column
  # from https://stackoverflow.com/questions/35279570/assign-point-color-depending-on-data-frame-column-value-r
  col <- as.character(df_clust$clust_color)
  names(col) <- as.character(df_clust$cluster)
  
  #plot the cluster number over date to see if there is a "trend"
  time_cluster_plot <- ggplot(df_clust, aes(x = date, y = 1)) +
    # color data point by cluster
    geom_tile(aes(fill = cluster))+
    scale_fill_manual(values = col)+
    scale_x_date(date_breaks = "1 month", date_labels = '%B')+
    theme_bw()+
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )+
    ggtitle(paste('Home', home_id))
  
  return(list(pca_cluster_plot, time_cluster_plot))
}

```

```{r, eval = TRUE, fig.width=10, fig.height=3}
hm <- '001'
# 2 feasible ac units...
cluster_df <- cluster.maker(hm, c('heat 6','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '002'
#
cluster_df <- cluster.maker(hm, c('furnace','ac 2'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '003'
# # home 3 not available?
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))
# # cluster.tests(cluster_df)
# cluster.plots(hm, cluster_df,3)

hm <- '004'
# no AC
cluster_df <- cluster.maker(hm, c('furnace'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,2)

hm <- '006'
#
cluster_df <- cluster.maker(hm, c('heat 1','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '007'
# 
cluster_df <- cluster.maker(hm, c('heat 2','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '008'
# many heats that could be feasible...
cluster_df <- cluster.maker(hm, c('heat 1','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '009'
# many heats that could be feasible...
cluster_df <- cluster.maker(hm, c('furnace','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '010'
# no ac (later enrollment), also no one heat that makes complete sense by itself...
cluster_df <- cluster.maker(hm, c('heat 2'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,2)

hm <- '011'
# no ac (later enrollment)
cluster_df <- cluster.maker(hm, c('heat 6'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,2)

hm <- '012'
#
cluster_df <- cluster.maker(hm, c('heat 2','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '013'
#
cluster_df <- cluster.maker(hm, c('heat 2','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '014'
# heat doesn't look feasible...
cluster_df <- cluster.maker(hm, c('heat 1','ac'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,3)

hm <- '015'
# on ac, multiple feasible heats
cluster_df <- cluster.maker(hm, c('heat 4'))
# cluster.tests(cluster_df)
cluster.plots(hm, cluster_df,2)

hm <- '016'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))
# # cluster.tests(cluster_df)
# cluster.plots(hm, cluster_df,3)

hm <- '017'
# # not available
# cluster_df <- cluster.maker(hm, c('heat 6','ac'))
# # cluster.tests(cluster_df)
# cluster.plots(hm, cluster_df,3)


```


