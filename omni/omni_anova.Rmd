---
title: "omni_anova"
author: "Andrew Purgiel"
date: "6/14/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra) #for making ggplot autocorrelation plot grids
library(ggpubr) # for normality test plots
library(rstatix)


```


```{r data_import, eval = FALSE}

export_date <- '2021-06-07'

##Import CSV with Real Time Data
omni_data<- read_csv(paste0('../output/omni_clean/',
                         'omni_all_locations_', export_date, '.csv'))


```


```{r functions_misc}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}

```

```{r define_variables}


#define homes for analysis
homes_all <- home.list(c(1:4, 7:16))

# define indoor rooms
locations_indoor <- c('living', 'bedroom', 'kitchen')

# # define homes that have data for all indoor rooms (if needed)
# homes_avail <- homes_all[-2]

# define metrics for acf testing
metrics_all <- c('pm25', 'voc', 'co2', 'temp', 'humid')

#define sizes for plot text
xsmall <- 2
small <- 4
medium <- 12
large <- 16

# define time spans needed for sample averages for different metrics
# to avoid auto-correlation
pm25_days <- 3
voc_days <- 6
co2_days <- 4
temp_days <- 6
humid_days <- 7

```

```{r avg_df_function, eval = FALSE}


avg.data <- function(data = omni_data, metric, days){
  data %>%
    select(datetime, home, location, all_of(metric)) %>%
          mutate(date = floor_date(datetime, unit = paste(days, 'days'))) %>%
          group_by(home, location, date) %>%
        # summarise_at(vars(all_of(metric)), list(mean = mean, sd = sd), na.rm = TRUE) %>%
    summarise_at(vars(all_of(metric)), list(~mean(., na.rm = TRUE), ~sd(., na.rm = TRUE),
                                  ~n())) %>%
    ungroup() %>%
    mutate(metric = metric, avg_period_days = days)
}
 
#test function
# a <- avg.data (metric = 'pm25', days = 3)


# # to make sure the dates were actual dates recorded for a sensor
# avg.data <- function(data = omni_data, metric, unit){
#   data %>%
#         # make a column of 3-day sequence between beginning and end
#     # date for each sensor
#           mutate(dateday = floor_date(datetime, unit = 'days')) %>%
#       group_by(home, location) %>%
# summarise(dateday = seq(min(dateday), max(dateday), by="3 days")) %>%
#     ungroup() 
#   #now figure out how to group each value into these intervals...
# }


```


```{r create_avg_df_csv, eval = FALSE}

# all homes/locations in one dataframe

a <- avg.data (metric = 'pm25', days = pm25_days)

b <- avg.data (metric = 'voc', days = voc_days)

c <- avg.data (metric = 'co2', days = co2_days)

d <- avg.data (metric = 'temp', days = temp_days)

e <- avg.data (metric = 'humid', days = humid_days)

omni_avg_data <- bind_rows(a,b,c,e)

write_csv(omni_avg_data, paste0('./csv_created/omni_avg_data_', Sys.Date(), '.csv'))
```

```{r import_avg_df}

omni_avg_data <- read_csv('./csv_created/omni_avg_data.csv')

```

```{r function_grid_plotting}

#function to put plots in a grid
plot.grid <- function(plots, title,
                     y_val = NULL, ncol = 4, nrow = 4) {
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  do.call('grid.arrange', c(plots, top = title, left = y_val,
                            ncol = ncol, nrow = nrow))  
  
}
```


# ANOVA Assumptions  

* note that pm25 and voc have been log-transformed on most of the analysis
* CO2 was as well, bt did not result in normality


## Outliers  

```{r function_assumption_outliers}
# test for outliers for one metric in one home for each location
outlier.test <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean))

    # # make box plot
  # boxplot <- ggplot(data_metric, aes(x = location, y = mean))+
  #   geom_boxplot()
  


  # identify outliers and extreme outliers and summarize numbers
  data_metric %>%
  group_by(location) %>%
  # take log transform of values if log.trans == TRUE
  mutate(mean = if(log.trans == TRUE) {log(mean)} else mean) %>%
 identify_outliers(mean) %>%
  group_by(location) %>%
  summarise_at(vars(is.outlier, is.extreme), list(n = function(x) sum(x == TRUE)))%>%
  ungroup()%>%
  full_join(
      # join with n of observations for each location
    data_metric %>%
    group_by(location) %>%
  summarise(n= n()) %>%
  ungroup(),
  by = 'location'
  )%>%
  mutate(outlier_pct = is.outlier_n/n*100, ex_outlier_pct = is.extreme_n/n*100,
         home = hm)
}


# # test function
# a <- outlier.test( hm = '001', met = 'pm25', log.trans = TRUE)
```


```{r assumption_outliers}


# make outlier df for all homes/locations
outliers_homes <- map(homes_all, function(x) outlier.test(hm = x, met = 'pm25',
                                                          log.trans = FALSE)) %>%
  bind_rows()

# make outlier df for all homes/locations
outliers_homes_log <- map(homes_all, function(x) outlier.test(hm = x, met = 'pm25',
                                                          log.trans = TRUE)) %>%
  bind_rows()
  
```


## Normality  

```{r function_assumption_normality}

# test for normality for each location in one home for one metric
qqplotter <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean)) %>%
    mutate(mean = if(log.trans == TRUE) {log(mean)} else mean)


# Create a QQ plot of values by location
ggqqplot(data_metric, 'mean', facet.by = 'location',
                   title = paste('Home', hm, met,
                                 if(log.trans == TRUE) {
                     'log-transformed'} else 'raw data')
)



}

#   # test function
# a <- qqplotter( hm = '001', met = 'pm25', log.trans = TRUE)


```

```{r plot_assumption_normality, fig.width=10.5, fig.height=8}
# make qqplots for all homes/locations/metrics
map(homes_all, function(x) qqplotter(hm = x, met = 'pm25',
                                        log.trans = TRUE)) %>%
  plot.grid(title = '')

map(homes_all, function(x) qqplotter(hm = x, met = 'voc',
                                        log.trans = TRUE)) %>%
  plot.grid(title = '')

map(homes_all, function(x) qqplotter(hm = x, met = 'co2',
                                        log.trans = TRUE)) %>%
  plot.grid(title = '')


```

## Homogeneous Variances  

```{r function_assumptions_variance}


# test for equal variances across locations for one home, for one metric
levene.tester <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean)) %>%
    mutate(mean = if(log.trans == TRUE) {log(mean)} else mean)


  levene_mean <- car::leveneTest(mean ~ as.factor(location),
                                 data=data_metric, center="mean")
  levene_median <- car::leveneTest(mean ~ as.factor(location),
                                   data=data_metric, center="median")

  tibble('home' = hm,
         'p_val_mean' = levene_mean[['Pr(>F)']][[1]],
         'p_val_median' = levene_median[['Pr(>F)']][[1]])

}

# # test function
# levene.tester(hm = '001', met = 'pm25', log.trans = TRUE)


```


```{r df_assumption_variances}

# test variances for all homes/locations/metrics
map(homes_all, function(x) levene.tester(hm = x, met = 'pm25',
                                        log.trans = TRUE)) %>%
  bind_rows

map(homes_all, function(x) levene.tester(hm = x, met = 'voc',
                                        log.trans = TRUE)) %>%
  bind_rows

map(homes_all, function(x) levene.tester(hm = x, met = 'co2',
                                        log.trans = TRUE)) %>%
  bind_rows


```


# Sum of Squares  

```{r function_sum_squares, eval = FALSE}

sum.square<- function(data = omni_avg_data, hm, met,
                              log.trans = FALSE) {
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean))%>%
        mutate(mean = if(log.trans == TRUE) {log(mean)} else mean)

  # grand mean of all data
  grand_mean <- data_metric %>%
    pull(mean) %>%
    mean()
  
  grand_n <- data_metric %>%
    pull(mean) %>%
    length()
  
  # sum of squares between each location mean and grand mean
  ss_between <- data_metric %>%
    group_by(location) %>%
    summarise_at(vars(mean), list(ss.between = function(x) {
      n()*(mean(x)-grand_mean)^2})) %>%
    ungroup() %>%
    # sum the between-location variances
    pull(ss.between) %>%
    sum()
  

   a <- data_metric %>%
    group_by(location) %>%
         # sum of squares between each data point at a location
  # and that location's mean
    summarise_at(vars(mean), list(ss.within = function(x) {sum((x-mean(x))^2)})) %>%
    ungroup() %>%
    t() %>% # transpose
     as.data.frame()
   
   colnames(a) <- a[1,]
   
   a[-1,] %>%
     rename_all(function(x) paste0('within_',x))%>%
     mutate_all(as.numeric) %>%
    mutate(between = ss_between, home = hm, metric = met)
  

  }

# # test function
# a <- sum.square(hm = '001', met = 'pm25', log.trans = TRUE)



```

```{r df_sum_squares, eval = FALSE}

# test variances for all homes/locations/metrics
ss_df <- map(metrics_all, function(x_metric) {
  
  map(homes_all, function(x_home) {
    sum.square(hm = x_home, met = x_metric,
               log.trans = TRUE)
  }
  )
}
) %>%
  bind_rows()

# write results into csv
write_csv(ss_df, paste0('./csv_created/sum_squares_', Sys.Date(),'.csv'))

# find when within-group ss is less than between group ss
ss_test <- ss_df %>%
  filter(within_bedroom<between |
         within_kitchen<between | 
           within_living<between )


```

