---
title: "omni_anova"
author: "Andrew Purgiel"
date: "6/14/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra) #for making ggplot autocorrelation plot grids
library(ggpubr) # for normality test plots
library(rstatix)


```


```{r data_import}

export_date <- '2021-06-07'

##Import CSV with Real Time Data
omni_data<- read_csv(paste0('../output/omni_clean/',
                         'omni_all_locations_', export_date, '.csv'))


```


```{r functions_misc}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}

```

```{r define_variables}


#define homes for analysis
homes_all <- home.list(c(1:4, 7:16))

# define indoor rooms
locations_indoor <- c('living', 'bedroom', 'kitchen')

# # define homes that have data for all indoor rooms (if needed)
# homes_avail <- homes_all[-2]

# define metrics for acf testing
metrics_all <- c('pm25', 'voc', 'co2', 'temp', 'humid')

#define sizes for plot text
xsmall <- 2
small <- 4
medium <- 12
large <- 16

# define time spans needed for sample averages for different metrics
# to avoid auto-correlation
pm25_days <- 3
voc_days <- 6
co2_days <- 4
temp_days <- 6
humid_days <- 7

```

```{r avg_df_function}


avg.data <- function(data = omni_data, metric, days){
  data %>%
    select(datetime, home, location, all_of(metric)) %>%
          mutate(date = floor_date(datetime, unit = paste(days, 'days'))) %>%
          group_by(home, location, date) %>%
        # summarise_at(vars(all_of(metric)), list(mean = mean, sd = sd), na.rm = TRUE) %>%
    summarise_at(vars(all_of(metric)), list(~mean(., na.rm = TRUE), ~sd(., na.rm = TRUE),
                                  ~n())) %>%
    ungroup() %>%
    mutate(metric = metric, avg_period_days = days)
}
 
#test function
# a <- avg.data (metric = 'pm25', days = 3)


# # to make sure the dates were actual dates recorded for a sensor
# avg.data <- function(data = omni_data, metric, unit){
#   data %>%
#         # make a column of 3-day sequence between beginning and end
#     # date for each sensor
#           mutate(dateday = floor_date(datetime, unit = 'days')) %>%
#       group_by(home, location) %>%
# summarise(dateday = seq(min(dateday), max(dateday), by="3 days")) %>%
#     ungroup() 
#   #now figure out how to group each value into these intervals...
# }


```


```{r create_avg_df_csv, eval = FALSE}

# all homes/locations in one dataframe

a <- avg.data (metric = 'pm25', days = pm25_days)

b <- avg.data (metric = 'voc', days = voc_days)

c <- avg.data (metric = 'co2', days = co2_days)

d <- avg.data (metric = 'temp', days = temp_days)

e <- avg.data (metric = 'humid', days = humid_days)

omni_avg_data <- bind_rows(a,b,c,e)

write_csv(omni_avg_data, paste0('./csv_created/omni_avg_data_', Sys.Date(), '.csv'))
```

```{r import_avg_df}

omni_avg_data <- read_csv('./csv_created/omni_avg_data.csv')

```

```{r anova_assumptions_tests}

outlier.test <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean))

    # # make box plot
  # boxplot <- ggplot(data_metric, aes(x = location, y = mean))+
  #   geom_boxplot()
  


  # identify outliers and extreme outliers and summarize numbers
  data_metric %>%
  group_by(location) %>%
  # take log transform of values if log.trans == TRUE
  mutate(mean = if(log.trans == TRUE) {log(mean)} else mean) %>%
 identify_outliers(mean) %>%
  group_by(location) %>%
  summarise_at(vars(is.outlier, is.extreme), list(n = function(x) sum(x == TRUE)))%>%
  ungroup()%>%
  full_join(
      # join with n of observations for each location
    data_metric %>%
    group_by(location) %>%
  summarise(n= n()) %>%
  ungroup(),
  by = 'location'
  )%>%
  mutate(outlier_pct = is.outlier_n/n*100, ex_outlier_pct = is.extreme_n/n*100,
         home = hm)
}


# test function
a <- outlier.test( hm = '001', met = 'pm25', log.trans = TRUE)

# make outlier df for all homes/locations
outliers_homes <- map(homes_all, function(x) outlier.test(hm = x, met = 'pm25',
                                                          log.trans = FALSE)) %>%
  bind_rows()

# make outlier df for all homes/locations
outliers_homes_log <- map(homes_all, function(x) outlier.test(hm = x, met = 'pm25',
                                                          log.trans = TRUE)) %>%
  bind_rows()
  
 

qqplot.homes <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean)) %>%
    mutate(mean = if(log.trans == TRUE) {log(mean)} else mean) %>%


# Create a QQ plot of values by location
ggqqplot(data_metric, 'mean', facet.by = 'location',
                   title = if(log.trans == TRUE) {
                     'log-transformed'} else 'raw data')



}

  # test function
a <- qqplot.homes( hm = '001', met = 'pm25', log.trans = TRUE)


qqplot.homes <- function(data = omni_avg_data, hm, met, log.trans = FALSE){
  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
  filter(home == hm & location %in% locations_indoor & metric == met) %>%
    filter(!is.na(mean)) %>%
    mutate(mean = if(log.trans == TRUE) {log(mean)} else mean) %>%


# Create a QQ plot of values by location
  ## raw
qqplot <- ggqqplot(data_metric, 'mean', facet.by = 'location',
                   title = if(log.trans == TRUE) {
                     'log-transformed'} else 'raw data')


# # Compute Shapiro-Wilk test of normality
# shaptest_log <- data_metric %>%
#   group_by(location) %>%
#   shapiro_test(log)
# 
# densityplots <- lapply(locations_indoor, function(x) {
#   density(data_metric %>% filter(location == x) %>% pull(log)) %>% plot()
# }
# ) %>% unlist()

# inverse hyperbolic sine (ihs)-transformed cols ---------------------------

# # function to add ihs columns to dataframe
# ihs.cols <- function(data) {
#   #select the identifying columns
#   data %>%
#   # select(home, room, date, location) %>%
#   cbind(
#     ##bind them to the ihs data columns
#     data %>%
#     transmute_if(is.numeric,list( ihs = asinh)))
# }



    return(list(
      # boxplot,
      outliers_summary
      # qqplot_log,
      # shaptest_log,
      # densityplots
      ))
}



```

