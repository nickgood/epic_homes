---
title: "Normality of Different Resolutions"
author: "Andrew Purgiel"
date: "7/4/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra) #for making ggplot autocorrelation plot grids
library(ggpubr) # for normality test plots
library(rstatix)


```


```{r import_minutely_data}
##Import cleaned CSV with Real Time Data
omni_data<- read_csv(paste0('./csv_created/',
                         'omni_all_locations.csv'))
```

```{r import_hourly_data}
##Import CSV with Real Time Data
omni_hourly_data<- read_csv(paste0('./csv_created/',
                         'omni_hourly_data.csv'))
```

```{r import_daily_data}
##Import cleaned CSV with Real Time Data
omni_daily_data<- read_csv(paste0('./csv_created/',
                         'omni_daily_data.csv'))
```



```{r functions_misc}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}

```

```{r define_variables}

#define homes for analysis
homes_all <- home.list(c(1:4, 7:16))

# define indoor rooms
locations_indoor <- c('living', 'bedroom', 'kitchen')

# define all resolutions of data to be tested
res_all <- c('day', 'hour', '5min')


# define metrics for acf testing
metrics_all <- c('pm25', 'voc', 'co2', 'temp', 'humid')

#define sizes for plot text
xsmall <- 2
small <- 4
medium <- 12
large <- 16

# define time spans needed for sample averages for different metrics
# to avoid auto-correlation
pm25_days <- 3
voc_days <- 6
co2_days <- 4
temp_days <- 6
humid_days <- 7

```

```{r function_grid_plotting}

#function to put plots in a grid
plot.grid <- function(plots, title,
                     y_val = NULL, ncol = 4, nrow = 4) {
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  do.call('grid.arrange', c(plots, top = title, left = y_val,
                            ncol = ncol, nrow = nrow))  
  
}
```


## Log Normality  

```{r function_normality_test}

# test for normality for each location in one home for one metric
qqplotter <- function(hm, met, resolution, log.trans = TRUE){
  
  data <- if(resolution == '5min') omni_data else
    if(resolution == 'hour') omni_hourly_data else
    if(resolution == 'day') omni_daily_data
  
  if(met %in% c('pm25', 'voc')) {
    # define LOD of metric to be 1/2 minimum detected (non-zero) value
    LOD <- data %>%
      filter(!!sym(met)!=0) %>%
      pull(all_of(met))%>%
      min()
    
    # change all zero values to LOD/2
    data <- data %>%
        mutate_at(all_of(met), function(x) ifelse(x==0, LOD/2, x))
  }
  

  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
      select(home, location, all_of(met)) %>%
  filter(home == hm & location %in% locations_indoor) %>%
    filter(!is.na(met)) %>%
    mutate(value = if(log.trans == TRUE) {log(get(met))} else get(met))


# Create a QQ plot of values by location
ggqqplot(data_metric, 'value', facet.by = 'location',
                   title = paste('Home', hm, met,
                                 if(log.trans == TRUE) {
                     'log-transformed'} else 'raw data')
)
}

#   # test function
# qqplotter( hm = '002', met = 'pm25', resolution = 'hour',log.trans = TRUE)


```

```{r plot_normality_diff_resolutions, fig.width=10.5, fig.height=8, eval = TRUE}
# make qqplots for all homes/locations/metrics

# pm25------------------
met <- 'pm25'

res <- 'day'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))

res <- 'hour'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))

res <- '5min'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))


# voc------------------
met <- 'voc'

res <- 'day'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))

res <- 'hour'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))

res <- '5min'
map(homes_all, function(x) qqplotter(hm = x, met = met,
                                     resolution = res,
                                        log.trans = TRUE)) %>%
  plot.grid(title = paste('Resolution =', res))


```


## Plot Tests of different distributions


```{r function_plot_distribution_tests}

# test for normality for each location in one home for one metric
distribution.plotter <- function(hm, met, resolution){
  
  data <- if(resolution == '5min') omni_data else
    if(resolution == 'hour') omni_hourly_data else
    if(resolution == 'day') omni_daily_data
  
  if(met %in% c('pm25', 'voc')) {
    # define LOD of metric to be 1/2 minimum detected (non-zero) value
    LOD <- data %>%
      filter(!!sym(met)!=0) %>%
      pull(all_of(met))%>%
      min()
    
    # change all zero values to LOD/2
    data <- data %>%
        mutate_at(all_of(met), function(x) ifelse(x==0, LOD/2, x))
  }

  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
      select(home, location, all_of(met)) %>%
  filter(home == hm & location %in% locations_indoor) %>%
    filter(!is.na(met))

  rooms_avail <- levels(data_metric %>% pull(location) %>% as.factor())

    
  map(rooms_avail, function(room) {
    
  a <- data_metric %>% filter(location ==room)
    
   fit_log <- fitdistrplus::fitdist(pull(a, met),
                                        "lnorm", method = 'mle')%>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) NULL)

    
        fit_weib <- fitdistrplus::fitdist(pull(a, met),
                                        "weibull", method = 'mle')%>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) NULL)
        
    fit_gam <- fitdistrplus::fitdist(pull(a, met),
                                        "gamma", method = 'mle')%>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) NULL)

     plot.legend <- c("lnorm", "weib", "gam")

            #remove null objects from plot_list and legend
        plot_list <- list(fit_log, fit_weib, fit_gam)
        
        null_plots <- sapply(plot_list, is.null)
        
        plot_list[null_plots] <- NULL
        plot.legend[null_plots] <- NA


        if(length(plot_list)==0) {
          # return NULL list if no plots were created
          list(NULL, NULL, NULL, NULL)
        } else {
          
          a <- fitdistrplus::denscomp(plot_list, legendtext = plot.legend,
                           main = paste('dens', hm, met, room, resolution),
                           plotstyle = 'ggplot')
    
    
   b <-  fitdistrplus::qqcomp(plot_list, legendtext = plot.legend,
                         main = paste('qq', hm, met, room, resolution),
                           plotstyle = 'ggplot')

    c <- fitdistrplus::cdfcomp(plot_list, legendtext = plot.legend,
                          main = paste('cdf', hm, met, room, resolution),
                           plotstyle = 'ggplot')

   d<-  fitdistrplus::ppcomp(plot_list, legendtext = plot.legend,
                         main = paste('pp', hm, met, room, resolution),
                           plotstyle = 'ggplot')
   list(a, b, c, d)
        }
   
                }# end of map function
) %>%
  flatten() %>%
  plot.grid(title = hm, ncol = 4,nrow = 3)
}

# test function-------------------

# distribution.plotter('010', 'voc', 'day')

```

### PM2.5  

```{r pm25_plot_distribution_tests, fig.width=10.5, fig.height=6, eval = FALSE}
met <- 'pm25'

map(homes_all,function (x_home) {
  map(res_all, distribution.plotter, met = met, hm = x_home)
}
)

```

### TVOC  

```{r voc_plot_distribution_tests, fig.width=10.5, fig.height=6, eval = FALSE}
met <- 'voc'

map(homes_all,function (x_home) {
  map(res_all, distribution.plotter, met = met, hm = x_home)
}
)

```

## Calculate AIC for each distribution  

```{r function_df_best_distribution}
 
# test for normality for each location in one home for one metric
distribution.compare <- function(hm, met, resolution){
  
  data <- if(resolution == '5min') omni_data else
    if(resolution == 'hour') omni_hourly_data else
    if(resolution == 'day') omni_daily_data
  
  if(met %in% c('pm25', 'voc')) {
    # define LOD of metric to be 1/2 minimum detected (non-zero) value
    LOD <- data %>%
      filter(!!sym(met)!=0) %>%
      pull(all_of(met))%>%
      min()
    
    # change all zero values to LOD/2
    data <- data %>%
        mutate_at(all_of(met), function(x) ifelse(x==0, LOD/2, x))
  }

  
  # create df of one metric for indoor rooms
  data_metric <- data %>%
      select(home, location, all_of(met)) %>%
  filter(home == hm & location %in% locations_indoor) %>%
    filter(!is.na(met))

  rooms_avail <- levels(data_metric %>% pull(location) %>% as.factor())

  
  map(rooms_avail, function(room) {
    
  a <- data_metric %>% filter(location ==room)
    
   fit_log_aic <- (fitdistrplus::fitdist(pull(a, met),
                                        "lnorm", method = 'mle') %>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) list('aic' = NA)))$aic

    
        fit_weib_aic <- (fitdistrplus::fitdist(pull(a, met),
                                        "weibull", method = 'mle')%>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) list('aic' = NA)))$aic
        
    fit_gam_aic <- (fitdistrplus::fitdist(pull(a, met),
                                        "gamma", method = 'mle')%>%
                     suppressWarnings()%>%
                     tryCatch(error = function(e) list('aic' = NA)))$aic
    
    

   list(
     'log' = fit_log_aic,
     'weib' = fit_weib_aic,
     'gam' = fit_gam_aic,
     'home' = hm,
     'location' = room)
   
                }# end of map function
) %>%
  bind_rows()
}

```

### PM2.5    

```{r pm25_best_dist, fig.width=10.5, fig.height=4, eval = FALSE}

met <- 'pm25'

# pm25

res <- 'day'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot<- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

a <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}
plot

res <- 'hour'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot<- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

b <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}
plot

res <- '5min'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot <- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

c <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}

plot

# combine summary dataframes of different resolutions
dist_compare_pm25 <- bind_rows(a,b,c) %>%
  mutate(metric = met)

# return table
dist_compare_pm25
```


### TVOC  

```{r voc_best_dist, fig.width=10.5, fig.height=4, eval = FALSE}

met <- 'voc'

# voc

res <- 'day'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot<- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

a <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}
plot

res <- 'hour'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot<- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

b <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}
plot

res <- '5min'
{
dist_compare_df <- map(homes_all, function (x_home){
  distribution.compare(x_home, met, res)
  }
  ) %>% bind_rows() %>%
  mutate( sensor = paste(location, home, sep = '_')) %>%
  pivot_longer(cols = c(log, weib, gam), names_to = 'dist_type',
               values_to = 'aic') %>%
  group_by(sensor) %>%
  mutate(max = max(aic)) %>%
  mutate(max = ifelse(max ==aic, TRUE, FALSE)) %>%
  ungroup()

# plot the aic of different distribution fits for each sensor
plot <- ggplot(dist_compare_df, aes(x = sensor, y = aic, fill = dist_type, color = max))+
  geom_col(position = 'dodge')+
  scale_color_manual(values = c('black', NA), breaks = c(TRUE, FALSE))+
  ggtitle(paste('AIC Value, Resolution =', met, res))

# calculate precentages

c <- dist_compare_df %>%
  filter(max == TRUE) %>%
  group_by(dist_type) %>%
  summarise(n_max = n()) %>%
  mutate(pct_max = n_max/sum(n_max), resolution = res)
}

plot

# combine summary dataframes of different resolutions
dist_compare_voc <- bind_rows(a,b,c) %>%
  mutate(metric = met)

# return table
dist_compare_voc
```

### COmbined  

```{r best_dist, eval = FALSE}
dist_compare_all <- bind_rows(dist_compare_pm25, dist_compare_voc)

dist_compare_all

# write_csv(dist_compare_all, './csv_created/distribution_comparison.csv')

```


