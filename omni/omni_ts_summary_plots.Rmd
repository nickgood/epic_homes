---
title: "Time Series Summary Plots"
author: "Andrew Purgiel"
date: "7/22/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

---

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra)
# library(tidymodels) # to discretize data for histogram
library(arules) # to discretize data for histogram
```

```{r data_import}
omni_hourly <- read_rds('./csv_created/omni_hourly_calibrated.rds') %>%
  rename(datetime = datehour)

home_type_df <- read_csv('../sense/csv_created_sense/home_type_df.csv')
```

# only use data up to June 2021
# and rename noise variable
```{r censor_date}
omni_hourly <- omni_hourly %>% filter(datetime<ymd_hms('2021-06-01 00:00:00'))%>%
  rename('noise' = spl_a)


```


```{r functions_misc}

 # misc------------------------------------------------

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


 # function to extract a legend from one plot for use in whole plot grid
 # reference: https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots
 g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}
 



#Mean and sd functions to ignore NA values
mean_NA <- function(x, na.rm = na.rm) {
  mean(x, na.rm = TRUE)}

sd_NA <- function(x, na.rm = na.rm) {
  sd(x, na.rm = TRUE)}

#Function to only display 3 significant figures (for tables)
signif3 <- function(x){
  signif(x, digits = 3)
}



#Function found online for geometric mean to use for plots
#webpage: https://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in
#adjusted so zeros are not ignored, just added one, to all values and subtract at end
#adjusted "length" to ignore values that are NA


gm = function(x, na.rm=TRUE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(any(x == 0, na.rm = TRUE)){
    exp(sum(log(x+1), na.rm=na.rm) / length(x[!is.na(x)]))-1
  }
  else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x[!is.na(x)]))
  }
}



#make low and high sd "interval" functions
low.sd = function(x){
  mean_NA(x)-sd_NA(x)
}

high.sd = function(x){
  mean_NA(x)+sd_NA(x)
}


#create function for standard error
std.error = function(x, na.rm=TRUE){
  sd_NA(x)/sqrt(length(x[!is.na(x)]))
}

##make low and high 95% conf interval (default 95%)
low.conf = function(x){
  gm(x)-1.96*std.error(x)
}

high.conf = function(x){
  gm(x)+1.96*std.error(x)
}





# labeller

# make function to label metric names with subscripts and seasons
labeller.all <- as_labeller(c(
  'pm25'='PM[2.5]', 'voc'="TVOC",
  'co2' = 'CO[2]', 'temp' = 'Temperature', 'humid' = 'Humidity',
  'lux' = 'Light', 'spl_a' = 'Noise',
  'ac' = 'Cooling', 'shoulder' = 'Shoulder', 'heat' = 'Heating',
  'kitchen' = 'Kitchen', 'living' = 'Living Room', 'bedroom' = 'Bedroom',
  'outdoor' = 'Outdoor', 'garage'= 'Garage'
  ), default = label_parsed)
  
```



# functions for plotting multiple time averaging periods in one grid
```{r functions_grids, eval = FALSE}
  # hourly simple plot-----------------------------------



    # plot without labels and such
    plot.hourly.simp <- function(dat, metric, err_ribbon = TRUE) {
      
      # define upper y-limit for plot based on metric
      y_range <- case_when(
        metric == 'pm25' ~ pm25_lim,
        metric == 'voc' ~ voc_lim,
        metric == 'co2' ~ co2_lim,
        metric == 'temp' ~ temp_lim,
        metric == 'humid' ~ humid_lim,
        metric == 'lux' ~ lux_lim,
        metric == 'spl_a' ~ spl_a_lim)
      
      ggplot(dat, aes(x = hour, y = get(paste0(metric, '_mean.val')), color = home))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(metric, '_high.val')),
                        ymin = get(paste0(metric, '_low.val')), fill = home),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = metric,
             x = NULL)+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.y = element_blank(),
      axis.text.x = element_text(size = xsmall),
      axis.title = element_blank(),
      legend.position = 'none')+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)
      
    }
    
    
    
    # daily simple plot-----------------------------------
    
    
    # plot without labels and such
    plot.weekday.simp <- function(dat, metric, err_ribbon = TRUE) {
      
      # define upper y-limit for plot based on metric
      y_range <- case_when(
        metric == 'pm25' ~ pm25_lim,
        metric == 'voc' ~ voc_lim,
        metric == 'co2' ~ co2_lim,
        metric == 'temp' ~ temp_lim,
        metric == 'humid' ~ humid_lim,
        metric == 'lux' ~ lux_lim,
        metric == 'spl_a' ~ spl_a_lim)
      
      ggplot(dat, aes(x = weekday, y = get(paste0(metric, '_mean.val')), color = home,
                      group = home))+ # need group to plot line for categorical variable
        geom_line( size = line_size)+
        #geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(metric, '_high.val')),
                        ymin = get(paste0(metric, '_low.val')), fill = home),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = metric,
             x = NULL)+
        
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = xsmall),
              axis.title = element_blank(),
              legend.position = 'none')+
        # make point size proportional to # of obs, with 0 obs = size 0
        geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)
    }
    
    

    
    # monthly simple plot-----------------------------------
    
    

    # plot without labels and such
    plot.monthly.simp <- function(dat, metric, err_ribbon = TRUE) {
      
      # define upper y-limit for plot based on metric
      y_range <- case_when(
        metric == 'pm25' ~ pm25_lim,
        metric == 'voc' ~ voc_lim,
        metric == 'co2' ~ co2_lim,
        metric == 'temp' ~ temp_lim,
        metric == 'humid' ~ humid_lim,
        metric == 'lux' ~ lux_lim,
        metric == 'spl_a' ~ spl_a_lim)
      
      ggplot(dat, aes(x = month, y = get(paste0(metric, '_mean.val')), color = home,
                      group = home))+ # need group to plot line for categorical variable
        geom_line( size = line_size)+
        #geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(metric, '_high.val')),
                        ymin = get(paste0(metric, '_low.val')), fill = home),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = metric,
             x = NULL)+
        
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = xsmall),
              axis.title = element_blank(),
              legend.position = 'none')+
        # make point size proportional to # of obs, with 0 obs = size 0
        geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)
    }
    
    
    
  
# grid simple plot-----------------------------------------

##Function to make table for plots of real time OMNI data
##averaged by hour of day, weekday, month, or a combination
time.plot <- function(data, period,
                      metrics, # metrics to plot (i.e. c('pm25', 'voc'))
                       start_date = "1900-01-13 00:00:00",
                       end_date = "9999-08-13 00:00:00",
                       groupers = NULL, # vector of variables to group by
                       # arithmetic mean if FALSE, geometric if TRUE 
                       geometric = FALSE,
                      err_ribbon_plot = TRUE
                       ) {
  
  #use start and end date to define timespan during which to use data
  a <- data %>%
    filter(datetime > ymd_hms(start_date) &
             datetime < ymd_hms(end_date))
  
  #if geo is FALSE (default), use arithmetic mean and standard deviation
  #to plot line and error bars respectively
  #if geo is TRUE, use geometric mean and 95% conf interval
  #to plot line and error bars respectively
  if(geometric == FALSE){
    mean.val <- function(x) {mean_NA(x)}
    high.val <- function(x) {high.sd(x)}
    low.val <- function(x) {low.sd(x)}
  } else {
    mean.val <- function(x) {gm(x)}
    high.val <- function(x) {high.conf(x)}
    low.val <- function(x) {low.conf(x)}
  }
  
  #####average and plot values by the specified time period
  #hour of day
  if (period == 'hour'){
    a <- a %>% 
      mutate(hour = hour(datetime)) %>%
      count(hour, home) %>% # count amount of observations used for each average
      full_join(
        a %>%
          mutate(hour = hour(datetime)) %>%
      group_by(hour, .dots = groupers) %>% 
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val))%>%
      ungroup()) %>%
      mutate(hour = as.numeric(hour))
    
    
    a <- lapply(metrics, plot.hourly.simp, dat = a, err_ribbon = err_ribbon_plot)
    
          a<- do.call('grid.arrange', c(a, ncol = 1))

  }
  
  #weekday
  if (period == 'day'){
    a <- a %>% 
      mutate(weekday = wday(datetime, label = TRUE)) %>% 
      count(weekday, home) %>% # count amount of observations used for each average
      full_join(
        a %>%
          mutate(weekday = wday(datetime, label = TRUE)) %>% 
          
      group_by(weekday, .dots = groupers) %>% 
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val))%>%
      ungroup())
    
    
    
    a <- lapply(metrics, plot.weekday.simp, dat = a, err_ribbon = err_ribbon_plot)
    
              a<- do.call('grid.arrange', c(a, ncol = 1))


  }
  
  
  #month
  if (period == 'month'){
    a <- a %>% 
      mutate(month = month(datetime, label = TRUE)) %>%
      count(month, home) %>% # count amount of observations used for each average
      full_join(
        a %>%
          mutate(month = month(datetime, label = TRUE)) %>%
          
      group_by(month, .dots = groupers) %>% 
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val))%>%
      ungroup())
    
    
    a <- lapply(metrics, plot.monthly.simp, dat = a, err_ribbon = err_ribbon_plot)
    
              a<- do.call('grid.arrange', c(a, ncol = 1))

  }
  

  return(a)

  }


 # grid functions--------------------
hour.day.month.grid <- function(location, err_ribbon_plot1 = TRUE,
                                note = NULL,
                                start_date1 = "1900-01-13 00:00:00",
                       end_date1 = "9999-08-13 00:00:00") {
    a <- lapply(periods_all, time.plot,
                data = get(paste0(location, '_data')), metrics = metrics_all,
                groupers = c('home'),
                err_ribbon_plot = err_ribbon_plot1,
                start_date = start_date1,
                       end_date = end_date1)
    
    a <- do.call('grid.arrange', c(a, ncol = 3,
                                   top = paste(location, start_date1,
                                               end_date1, note, sep = '_'))) 
    
    # change name of file if not using error ribbon
            # add note to file name if specified

    file_name <- if_else(
      err_ribbon_plot1 == TRUE,
      paste0('grid_', location, '_', Sys.Date(), '_', note, '.pdf'),
      paste0('grid_', location, '_noribbon_', Sys.Date(), '_', note, '.pdf'))
    
    
    # save file as pdf
      ggsave(file_name,
           plot = a , width = 8, height = 10.5, units = 'in')
      
}

# testing----------

# rm <- 'living'
# 
# # test for all monitoring period
# 
# version <- 'all time'
# hour.day.month.grid(rm, err_ribbon_plot1 = TRUE, note = version)
# 
# 
# 
# # test for fall
# season <- c('2020-9-22 00:00:00','2020-12-21 23:59:00')
# season_start <- season[1]
# season_end <- season[2]
# 
# version <- 'fall'
#   
# rm <- 'living'
# # hour.day.month.grid(rm)
# hour.day.month.grid(rm, err_ribbon_plot1 = FALSE, note = version,
#                     start_date1 = season_start, end_date1 = season_end)
# 
# rm <- 'kitchen'
# # hour.day.month.grid(rm)
# hour.day.month.grid(rm, err_ribbon_plot1 = FALSE, note = version,
#                     start_date1 = season_start, end_date1 = season_end)
# 
# rm <- 'bedroom'
# # hour.day.month.grid(rm)
# hour.day.month.grid(rm, err_ribbon_plot1 = FALSE, note = version,
#                     start_date1 = season_start, end_date1 = season_end)
# 
# rm <- 'outdoor'
# # hour.day.month.grid(rm)
# hour.day.month.grid(rm, err_ribbon_plot1 = FALSE, note= version, 
#                     start_date1 = season_start, end_date1 = season_end)
# 
# rm <- 'garage'
# # hour.day.month.grid(rm)
# hour.day.month.grid(rm, err_ribbon_plot1 = FALSE, note = version,
#                     start_date1 = season_start, end_date1 = season_end)


 



```


# function for making data at given time averaging periods
```{r}
##Function to make table for plots of real time OMNI data
##averaged by hour of day, weekday, month, or a combination
time.table <- function(data, period, met,
                       start_date = "1900-01-13 00:00:00",
                       end_date = "9999-08-13 00:00:00",
                       groupers = NULL, # vector of variables to group by
                       # arithmetic mean if FALSE, geometric if TRUE 
                       geometric = FALSE,
                       error = 'conf'
                       ) {
  
  #use start and end date to define timespan during which to use data
  a <- data %>%
    filter(datetime > ymd_hms(start_date) &
             datetime < ymd_hms(end_date)) %>%
    select(datetime, home, location, all_of(met), energy_cluster)
  
  #if geo is FALSE (default), use arithmetic mean and standard deviation
  #to plot line and error bars respectively
  #if geo is TRUE, use geometric mean and 95% conf interval
  #to plot line and error bars respectively
  if(geometric == FALSE){
    mean.val <- function(x) {mean(x, na.rm = TRUE)}

  } else if(geometric == TRUE){
    mean.val <- function(x) {gm(x)}

  }
  
  if(error == 'conf'){
    high.val <- function(x) {
      mean.val(x)+1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
    low.val <- function(x) {
      mean.val(x)-1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
} else if(error == 'sd'){
    high.val <- function(x) mean.val(x)+sd(x, na.rm = TRUE)
    low.val <- function(x) mean.val(x)-sd(x, na.rm = TRUE)
 }
  
  #####average and plot values by the specified time period
  #hour of day
  if (period == 'hour'){

    # average and plot values by hour of day
    a <- a %>%
      mutate(hour = hour(datetime))
    
    a <- a %>%
      group_by_at(.vars= c('hour', groupers)) %>%
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val)) %>%
      ungroup() %>%
      left_join(
        a %>%
          group_by_at(.vars= c('hour', groupers)) %>%
      summarize(n = n(), .groups = 'drop'),
      by = c('hour', groupers)
      )%>%
      mutate(hour = as.numeric(hour)
             ) %>% 
      mutate(metric = met)
    
      }
  
  #weekday
  if (period == 'day'){
    a <- a %>%
      mutate(weekday = wday(datetime, label = TRUE))
    
    a <- a %>%
      group_by_at(.vars= c('weekday', groupers)) %>%
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val)) %>%
      ungroup() %>%
      left_join(
        a %>%
          group_by_at(.vars= c('weekday', groupers)) %>%
      summarize(n = n(), .groups = 'drop'),
      by = c('weekday', groupers),
      )%>%
      mutate(metric = met)
    
  }
  
  # #weekday and hour of each day
  # if (period == 'day.hour'){
  #   a <- a %>% 
  #     mutate(weekday = wday(datetime, label = TRUE),
  #            hour = hour(datetime)) %>%
  #     group_by(weekday, hour, .dots = groupers) %>% 
  #     summarize_if(is.numeric, list(mean.val = mean.val,
  #                                   low.val = low.val,
  #                                   high.val = high.val))%>%
  #     ungroup() %>%
  #     mutate(hour = as.numeric(hour))
  #   
  # }
  
  #month
 # if (period == 'month'){
 #    a <- a %>% 
 #      mutate(month = floor_date(datetime, unit = 'month')) %>%
 #      count(month, home) %>% # count amount of observations used for each average
 #      full_join(
 #        a %>%
 #          mutate(month = floor_date(datetime, unit = 'month')) %>%
 #          
 #      group_by(month, .dots = groupers) %>% 
 #      summarize_if(is.numeric, list(mean.val = mean.val,
 #                                    low.val = low.val,
 #                                    high.val = high.val))%>%
 #      ungroup())
 # }
  
    #weekday
  if (period == 'month'){
    a <- a %>%
      mutate(month = floor_date(datetime, unit = 'month'))
    
    a <- a %>%
      group_by_at(.vars= c('month', groupers)) %>%
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val)) %>%
      ungroup() %>%
      left_join(
        a %>%
          group_by_at(.vars= c('month', groupers)) %>%
      summarize(n = n(), .groups = 'drop'),
      by = c('month', groupers),
      )%>%
      mutate(metric = met)
    
  }
  
  # #month and hour of each day
  # if (period == 'month.hour'){
  #   a <- a %>% 
  #     mutate(month = month(datetime, label = TRUE),
  #            hour = hour(datetime)) %>%
  #     group_by(month, hour, .dots = groupers) %>% 
  #     summarize_if(is.numeric, list(mean.val = mean.val,
  #                                   low.val = low.val,
  #                                   high.val = high.val))%>%
  #     ungroup() %>%
  #     mutate(hour = as.numeric(hour))
  #   
  # }
  
  #     if (period == 'date.day'){
  #   a <- a %>% 
  #     mutate(datetime = floor_date(datetime, unit = 'days')) %>%
  #     group_by(datetime, .dots = groupers) %>% 
  #     summarize_if(is.numeric, list(mean.val = mean.val,
  #                                   low.val = low.val,
  #                                   high.val = high.val))%>%
  #     ungroup() %>%
  #     mutate()
  # }

  return(a)

}
```


# define variables
```{r define_variables}

##For plot labeling pruposes
xsmall <- 6
small <- 15
medium <- 20
large <- 26
line_size <- 0.5
max_point_size <- 0.75

# define y-limits for metrics (for time series plots)
pm25_lim <- c(0,60)
voc_lim <- c(0,1500)
co2_lim <- c(0,2500)
temp_lim <- c(0,25)
humid_lim <- c(0,60)
lux_lim <- c(0,1000)
noise_lim <- c(40,70)

# define y-limits for metrics (for difference of means plots)
pm25_diff_lim <- c(-23,20)
voc_diff_lim <- c(-300,500)
co2_diff_lim <- c(-600,1250)
temp_diff_lim <- c(-5,3.5)
humid_diff_lim <- c(-9,9)
lux_diff_lim <- c(-500,750)
noise_diff_lim <- c(-9,9)

## for zoom:
#   pm25_lim <- c(0,40)
# voc_lim <- c(0,1000)
# co2_lim <- c(0,1500)
# temp_lim <- c(15,25)
# humid_lim <- c(20,60)
# lux_lim <- c(0,500)
# spl_a_lim <- c(40,70)




homes_all <- home.list(c(1:16))
homes_no5 <- home.list(c(1:4, 6:16))
homes_tier1 <- home_type_df %>% filter(home_type == 'tier1') %>% pull(home)
homes_tier2 <- home_type_df %>% filter(home_type == 'tier2') %>% pull(home)
homes_tier3 <- home_type_df %>% filter(home_type == 'tier3') %>% pull(home)

metrics_all <- c('pm25', 'voc', 'co2', 'temp','humid', 'lux', 'spl_a')
locations_indoor <- c('living', 'bedroom', 'kitchen')

periods_all <- c('hour', 'day', 'month')

living_data <- omni_hourly %>% filter(location == 'living')
kitchen_data <- omni_hourly %>% filter(location == 'kitchen')
bedroom_data <- omni_hourly %>% filter(location == 'bedroom')
outdoor_data <- omni_hourly %>% filter(location == 'outdoor')
garage_data <- omni_hourly %>% filter(location == 'garage')


# color blind pallette
# check http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
cbbPalette <- c('black' = "#000000",
                'light_orange' = "#E69F00",
                'light_blue' = "#56B4E9",
                'green' = "#009E73",
                'yellow' = "#F0E442",
                'dark_blue' = "#0072B2",
                'dark_orange' = "#D55E00",
                'purple' = "#CC79A7"
                )
# define colors for room-comparisons
room_colors <- c(cbbPalette['green'],
                   cbbPalette['purple'],
                   cbbPalette['light_orange']
                   )%>% unname()

room_breaks <- locations_indoor

room_labels <- c('Living Room', 'Bedroom', 'Kitchen')

# define colors for energy clusters
energy_colors <- c(cbbPalette['light_blue'],
                   cbbPalette['green'],
                   cbbPalette['dark_orange'],
                   cbbPalette['black'])%>% unname()

energy_breaks <- c('ac', 'shoulder', 'heat', 'overall')
energy_labels <- c('Summer', 'Shoulder', 'Winter', 'Entire Period')
```




# make example time series plot and histograms
```{r, fig.height= 3, fig.width = 7}
a <- omni_hourly %>%
  filter(home == '009', location == 'living') %>%
  filter(datetime > '2020-9-27' & datetime < '2020-11-27') %>%
  mutate(hour = hour(datetime))

date_seq <- seq.POSIXt(min(a$datetime), max(a$datetime), by = '6 day') # make a sequence of sample cutoffs


x_labels <- date_seq+ days(3)
x_labels <- x_labels[1:(length(x_labels)-1)] # omit last value
labels <- 1:(length(x_labels))

ggplot()+
  geom_line(data = a, aes(y = pm25, x = datetime))+
  geom_segment(aes(x = date_seq,
                   xend = date_seq,
                   y = 0, yend = max(a$pm25)+10), color = cbbPalette['dark_orange'],
               size = 1)+
    geom_segment(aes(x = min(a$datetime),
               xend = max( date_seq),
               y = max(a$pm25)+10, yend = max(a$pm25)+10), color = cbbPalette['dark_orange'],
               size = 1)+
      geom_segment(aes(x = min(a$datetime),
               xend = max( date_seq),
               y = 0, yend = 0), color = cbbPalette['dark_orange'],
               size = 1)+
  geom_text(aes(x = x_labels, y = max(a$pm25)+5, label = labels), color = cbbPalette['dark_orange'])+
  theme_classic()+
  ylab(expression(paste('PM'[2.5], ', ug/m'^3)))+
  xlab('Date')



# show plot with just sample 5

ggplot()+
  geom_line(data = a, aes(y = pm25, x = datetime))+
  geom_rect(aes(xmin = date_seq[5], xmax = date_seq[6],
                   ymin = 0, ymax = max(a$pm25)+10),
            color = cbbPalette['dark_orange'], fill = NA,
               size = 1
            )+
  geom_text(
    aes(y = max(a$pm25)),
    x = date_seq[5]+ days(3), label = 'Sample', color = cbbPalette['dark_orange'])+
  theme_classic()+
  ylab(expression(paste('PM'[2.5], ', ug/m'^3)))+
  xlab('Date')






```


```{r, fig.height= 2, fig.width = 3}

# extract sample 5
sample_dat <- a %>%
  filter(datetime >= date_seq[5] & datetime < date_seq[6])

# make density histograms of magnitudes of sample 5 and entire monitoring period,
# ensuring to use the same bins for each
a_mag <- table(discretize(a$pm25, method = 'interval', breaks = 20))%>%
  data.frame() %>%
  mutate(Freq = Freq/sum(Freq, na.rm = TRUE)) %>%
  rename('longterm' = Freq)

pm_breaks <- discretize(a$pm25, method = 'interval', breaks = 20, onlycuts = TRUE)

sample_dat_mag <- table(discretize(sample_dat$pm25, method = 'fixed', breaks = pm_breaks)) %>%
  data.frame()%>%
  mutate(Freq = Freq/sum(Freq, na.rm = TRUE)) %>%
  rename('sample' = Freq)

data_mag <- a_mag %>%
  left_join(sample_dat_mag, by = 'Var1') %>%
  pivot_longer(cols = c(longterm, sample), names_to = 'origin', values_to = 'freq') %>%
  rename('bin' = Var1) %>%
  mutate(bin = gsub('^.*,|\\)$', '', bin),
         bin = gsub(']', '', bin),
         bin = as.numeric(bin))

# # plot method 1
# ggplot() +
#   geom_histogram(data = a, aes(x = pm25, y = ..density..),
#                  fill = 'black', alpha = 0.5)+
#   geom_histogram(data = sample_dat, aes(x = pm25, y = ..density..),
#                  fill = cbbPalette['dark_orange'], alpha = 0.5)+
#   theme_classic()+
#   xlab(expression(paste('PM'[2.5], ', ug/m'^3)))+
#   ylab('Density')+
#   theme(
#     axis.text.y = element_blank(),
#     axis.ticks.y = element_blank()
#   )

# plot method 2

ggplot() +
  geom_col(data = data_mag, aes(x = bin, y = freq, fill = origin),
           position = 'dodge')+
  theme_classic()+
  xlab(expression(paste('PM'[2.5], ', ug/m'^3)))+
  ylab('Density')+
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )+
  scale_fill_manual(
    breaks = c('longterm', 'sample'),
    labels = c('Entire Season', 'Sample'),
    values = c('black', cbbPalette['dark_orange'] %>%unname()),
    name = 'Data Set'
  )+
  theme(
    legend.position = 'none'
  )



# histogram of time values
a_hr <- a %>%
  group_by(hour) %>%
  summarise(mean = mean(pm25, na.rm = TRUE), .groups = 'drop') %>%
  mutate(origin = 'longterm')

sample_dat_hr <- sample_dat %>%
  group_by(hour) %>%
  summarise(mean = mean(pm25, na.rm = TRUE), .groups = 'drop') %>%
  mutate(origin = 'sample')

data_hr <- a_hr %>%
  rbind(sample_dat_hr)

ggplot() +
  geom_col(data = data_hr, aes(x = hour, y = mean, fill = origin),
                 position = 'dodge')+

  theme_classic()+
  ylab(expression(paste('Average PM'[2.5], ', ug/m'^3)))+
  scale_fill_manual(
    breaks = c('longterm', 'sample'),
    labels = c('Entire Season', 'Sample'),
    values = c('black', cbbPalette['dark_orange'] %>%unname()),
    name = 'Data Set'
  )+
  scale_x_continuous(
    breaks = c(0,6,12,18),
    labels = c('12am', '6am', '12pm', '6pm')
  )+
  xlab('Hour of Day')+
  theme(
    legend.position = 'none'
  )

```


## Note: all plots use averaged hourly data to calculate means and confidence intervals  


# Hourly 

## Pooled homes


### function
```{r}

   # plot pooled by home, facet by room, one metric
      plot.hourly.pooled <- function(data) {
     
             # make a dummy df in which to define limits for each metric
limit_df <- data %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(data, aes(x = hour, y = mean.val))+
    geom_line( size = line_size)+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day',
          size= 'Home-Hours of Data')+
       
    scale_x_continuous(limits = c(0,24),
                       breaks = c(0,6,12,18),
                       labels = c('12am', '6am','12pm', '6pm'),
                       expand = c(0,0))+
    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      geom_point(aes(y = mean.val, size = n))+
        scale_size_area(max_size = max_point_size,
                        )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))
      }


```

###Plot
```{r, fig.height=4, fig.width=8}

a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  time.table(omni_hourly, 'hour', x_metric, groupers = 'location')
}
) %>% bind_rows()
  
# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))


# without temp
plot.hourly.pooled(data = a %>% filter(metric != 
                                         'temp'))

# with temp
plot.hourly.pooled(data = a)


```

## By Home


### function
```{r}

   # plot disag by home, facet by room, one metric
      plot.hourly.homes <- function(data) {
     
        

 # make a dummy df in which to define limits for each metric
limit_df <-
      data %>%
  group_by( metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


      ### plot
     ggplot(data, aes(x = hour, y = mean.val))+
    geom_line( aes(color = home), size = line_size)+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, fill = home),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day',
          color= 'Home',
          fill = 'Home')+
       
    scale_x_continuous(limits = c(0,24),
                       breaks = c(0,6,12,18),
                       labels = c('12am', '6am','12pm', '6pm'),
                       expand = c(0,0))+
    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
          axis.text.x = element_text(size = xsmall)
)+
        # make point size proportional to # of obs, with 0 obs = size 0
      # geom_point(aes(size = n, fill = home))+
      #   scale_size_area(max_size = max_point_size,
      #                   )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))
     }


```

###Plot
```{r, fig.height=4, fig.width=8}

a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  time.table(omni_hourly, 'hour', x_metric, groupers = c('home', 'location'))
}
) %>% bind_rows()

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

# all homes
plot.hourly.homes(data = a)

# high homes omit
plot.hourly.homes(data = a %>% filter(home != '003' , home!='015',
                                      home != '008' , home!='002'))

```


## By Season

### function
```{r}

   # plot disag by season, facet by room and etric
      plot.hourly.seasons <- function(data, n_homes) {
     
        
 # make a dummy df in which to define limits for each metric
limit_df <-
      data %>%
  group_by( metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


      ### plot
     ggplot(data, aes(x = hour, y = mean.val))+
    geom_line( aes(color = energy_cluster), size = line_size)+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, fill = energy_cluster),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day',
          color= 'Season',
          fill = 'Season',
          size = 'Home-Hours of Data')+
       
    scale_x_continuous(limits = c(0,24),
                       breaks = c(0,6,12,18),
                       labels = c('12am', '6am','12pm', '6pm'),
                       expand = c(0,0))+
    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
          axis.text.x = element_text(size = xsmall)
)+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      geom_point(aes(size = n, color = energy_cluster))+
        scale_size_area(max_size = max_point_size+0.5,
                        )+
        facet_wrap(vars(metric), nrow = 1, labeller = labeller.all,
                   scales = 'free_y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      # strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))+
               #ensure seaons legend on top
        guides(
    fill = guide_legend(order = 1),
        color = guide_legend(order = 1),
    size = guide_legend(order = 2)
  )+
        labs(tag = paste('*n homes =', n_homes) )+
      theme(
        plot.tag.position = c(.1,0.02),
        )+
                scale_fill_manual(
          breaks = energy_breaks,
          values = energy_colors,
          labels = energy_labels,
          aesthetics = c('fill', 'color')
        )
     }


```

###Plot for Group 2
```{r, fig.height=2.5, fig.width=8}

  homes <- homes_tier2

a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
  dat <- omni_hourly %>%
    filter( home %in% homes,
            energy_cluster %in% c('heat', 'shoulder', 'ac'))
    
  time.table(dat, 'hour', x_metric, groupers = c('energy_cluster'))
}
) %>% bind_rows()

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))



# plot
plot.hourly.seasons(data = a, n_homes = length(homes))


```

###Plot for Group 3
```{r, fig.height=2.5, fig.width=8}

  homes <- homes_tier3

a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
  dat <- omni_hourly %>%
    filter( home %in% homes,
            energy_cluster %in% c('heat', 'shoulder', 'ac'))
    
  time.table(dat, 'hour', x_metric, groupers = c('energy_cluster'))
}
) %>% bind_rows()

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

# plot
plot.hourly.seasons(data = a, n_homes = length(homes))


```



-----




# Weekday


## pooled homes

### function

```{r}

   # plot pooled home, facet by room, all metrics
      plot.weekday.pooled <- function(data) {
     
             # make a dummy df in which to define limits for each metric
limit_df <- data %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(data, aes(x = weekday, y = mean.val))+
    geom_line( size = line_size, aes(group = 1))+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, group = 1),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Weekday',
          size= 'Home-Hours of Data')+
       
    scale_x_discrete(
      breaks = c('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
      labels = c('Su', 'M', 'T', 'W', 'Th', 'F', 'Sa'),

                     )+
    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      geom_point(aes(y = mean.val, size = n))+
        scale_size_area(max_size = max_point_size,
                        )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'Wed', y = limits))
      }


```

### plot
```{r}
a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
    
  time.table(omni_hourly, 'day', x_metric, groupers = 'location')
}
) %>% bind_rows()

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))

plot.weekday.pooled(a)



```


## by home

### function

```{r}

   # plot pooled by home, facet by room, one metric
      plot.weekday.homes <- function(data) {
     
             # make a dummy df in which to define limits for each metric
limit_df <- data %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(data, aes(x = weekday, y = mean.val))+
    geom_line( size = line_size, aes(color = home, group = home))+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, fill = home, group = home),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Weekday',
          color= 'Home',
          fill = 'Home')+
       
    scale_x_discrete(
      breaks = c('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
      labels = c('Su', 'M', 'T', 'W', 'Th', 'F', 'Sa'),
                     )+
    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      # geom_point(aes(y = mean.val, size = n))+
        # scale_size_area(max_size = max_point_size,
        #                 )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'Wed', y = limits))
      }


```

### plot
```{r}
a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
    
  time.table(omni_hourly, 'day', x_metric, groupers = c('home','location'))
}
) %>% bind_rows()

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))


plot.weekday.homes(a)



```


------


# Monthly 


## By Home

```{r function_monthly_new_method}



      plot.monthly <- function(metric, data, location = NULL) {
     
              # define upper y-limit for plot based on metric
      y_range <- case_when(
        metric == 'pm25' ~ c(0,40),
        metric == 'voc' ~ voc_lim,
        metric == 'co2' ~ c(0,2000),
        metric == 'temp' ~ temp_lim,
        metric == 'humid' ~ humid_lim,
        metric == 'lux' ~ lux_lim,
        metric == 'noise' ~ noise_lim)
      
        #     y_label <- case_when(
        # metric == 'pm25' ~ expression('PM'[2.5]*', ppb'),
        # metric == 'voc' ~ 'TVOC, ppb',
        # metric == 'co2' ~ expression('CO'[2]*', ppb'),
        # metric == 'temp' ~ 'Temperature, deg C',
        # metric == 'humid' ~ 'Relative Humidity, %',
        # metric == 'lux' ~ 'Light, lx',
        # metric == 'noise' ~ 'Noise, dB')
      
     ggplot(data, aes(x = month, y = get(paste0(metric, '_mean.val')), color = home))+
    geom_line( aes(group = home), size = 1)+
    {if( is.null(location) | length(location) > 1) 
      facet_wrap(~factor(location, levels = c('living', 'kitchen', 'bedroom',
                                              'garage', 'outdoor')),
                 ncol = 5)}+
    ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
    # geom_ribbon(aes(ymax = get(paste0(metric, '_high.val')),
    #                 ymin = get(paste0(metric, '_low.val')), fill = home),
    #             alpha = 0.2, color = NA)+
    labs(y = paste('Average', metric),
         x = "Month")+
       scale_x_date(
                    breaks = c(seq(from=as.Date("2020-07-01"),to=as.Date("2021-06-01"),by="month")),
               labels = c(
                 sapply(month.abb[c(7:12,1:6)],
                                       substr, start = 1, stop = 1) %>% unname()))+ 
       scale_color_discrete(name = 'Home')+
    theme_bw()+
    theme(plot.title = element_blank(),
          title = element_text(size = medium),
          axis.text.y = element_text(size = small),
          axis.text.x = element_text(size = small-3),
          strip.text = element_text( size = medium),
          axis.title = element_text(size = medium),
          legend.title = element_text(size = medium-3),
          panel.spacing.x = unit(1, 'lines') # add horiz space between facets
          )+
               coord_cartesian(ylim = y_range)+
        # make point size proportional to # of obs, with 0 obs = size 0
        # geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size, guide = 'none')+
          ##for extra space between facets
    theme(
          strip.background =element_blank())
      }
      
      
```


```{r plot_monthly_new_method, fig.height=2.5, fig.width = 12 }

      a <- time.table(omni_hourly, 'month', groupers = c('home','location'))%>%
  filter(home %in% homes_no5) %>% mutate(month = as.Date(month))

plot.monthly('pm25', data = a)
plot.monthly('voc', data = a)
plot.monthly('co2', data = a)
plot.monthly('temp', data = a) 
```

## pooled homes

### line plot function

```{r}

   # plot pooled home, facet by room, all metrics
      plot.month.pooled <- function(data) {
     
             # make a dummy df in which to define limits for each metric
limit_df <- data %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(data, aes(x = as.Date(month), y = mean.val))+
    geom_line( size = line_size, aes(group = 1))+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, group = 1),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Month',
          size= 'Home-Hours of Data')+

scale_x_date(
                    breaks = c(seq(from=as.Date("2020-07-01"),
                                   to=as.Date("2021-06-01"),by="month")),
               labels = c(
                 sapply(month.abb[c(7:12,1:6)],
                                       substr, start = 1, stop = 1) %>% unname()))+    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      geom_point(aes(y = mean.val, size = n))+
        scale_size_area(max_size = max_point_size,
                        )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = as.Date('2020-10-01'), y = limits))+
       theme(  panel.grid.minor.x = element_blank() )
      }


```

### plot
```{r}
a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
    
  time.table(omni_hourly, 'month', x_metric, groupers = 'location')
}
) %>% bind_rows()

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))

# all metrics and locations
plot.month.pooled(a)

```





### box plot

```{r}

a <- omni_hourly %>%
  mutate(month = month(datetime, label = TRUE, abbr = TRUE)) %>%
  select(-c(noise, lux, humid, score)) %>%
  pivot_longer(c(co2:temp), names_to = 'metric', values_to = 'value')

# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))

a$month <- factor(a$month, levels = c(month.abb[c(7:12,1:6)]))
         # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(value))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(a, aes(x = month, y = value))+
    geom_boxplot(aes(group = month), outlier.size = 0.2)+
        labs(
             x = 'Month'
        )+
scale_x_discrete(
                    breaks = c(month.abb[c(7:12,1:6)]),
               labels = c(
                 sapply(month.abb[c(7:12,1:6)],
                                       substr, start = 1, stop = 1) %>% unname())
               )+
       theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      # geom_jitter()+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        # geom_blank(data = limit_df, aes(x = 'Oct', y = limits))+
       theme(  panel.grid.minor.x = element_blank() )




```








## by home

### function

```{r}

   # plot diasggragaetd homes, facet by room, all metrics
      plot.month.homes <- function(data) {
     
             # make a dummy df in which to define limits for each metric
limit_df <- data %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

      ### plot
     ggplot(data, aes(x = as.Date(month), y = mean.val))+
    geom_path( size = line_size, aes(color = home, group = home))+
    #geom_errorbar(aes(ymax = high.val, ymin = low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = high.val,
                    ymin = low.val, fill = home, group = home),
                alpha = 0.2, color = NA)+
        labs(
          y = 'Average Value',
             x = 'Month',
          fill = 'Home',
          color = 'Home')+

scale_x_date(
                    breaks = c(seq(from=as.Date("2020-07-01"),
                                   to=as.Date("2021-06-01"),by="month")),
               labels = c(
                 sapply(month.abb[c(7:12,1:6)],
                                       substr, start = 1, stop = 1) %>% unname()))+    theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
      axis.text.x = element_text(size = xsmall)
          )+
       facet_grid(c('metric', 'location'))+
        # make point size proportional to # of obs, with 0 obs = size 0
      # geom_point(aes(y = mean.val, size = n))+
      #   scale_size_area(max_size = max_point_size,
      #                   )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = as.Date('2020-10-01'), y = limits))+
       # set minimum to avoid cutting off min temps
       scale_y_continuous(limits = c(-5, NA))+
       theme(  panel.grid.minor.x = element_blank() )
      }


```

### plot
```{r}
a <- map(c('pm25', 'voc', 'co2', 'temp'), function(x_metric){
  
    
  time.table(omni_hourly, 'month', x_metric, groupers = c('home','location'))
}
) %>% bind_rows()%>%
  mutate(month = as.Date(month))%>%
  group_by(home, location, metric) %>%
  complete(month = seq.Date(as.Date('2020-07-01'), as.Date('2021-05-01'), by="month")) %>%
  ungroup()



# change order of metrics for plotting
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))

a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))

plot.month.homes(a)



```


------


# Daily


```{r date_day, eval = FALSE}



{A <- time.table(omni_hourly, 'date.day', groupers = 'location')
  
##PM2.5


   plotpm <- ggplot(A, aes(x = datetime, y = pm25_mean.val))+
    geom_line( size = 1)+
    ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = pm25_high.val, ymin = pm25_low.val),
                alpha = 0.2, color = NA, fill = 'orange')+
    labs(y = expression('PM'["2.5"]*'(ug/m'^3*')'),
         x = "Date",
         title = paste("PM - Average of Daily Values for all Homes"))+
    theme_bw()+
    coord_cartesian(ylim = c(0, 60))+
    theme(plot.title = element_text(hjust = 0.5),
          title = element_text(size = small),
          axis.text = element_text(size = medium),
          strip.text = element_text( size = large),
          axis.title = element_text(size = large))+
    geom_point(size = 1)+
         facet_wrap(~location)+
          ##for extra space between facets
    theme(panel.spacing = unit(1, "lines"),
          strip.background =element_blank())

##VOC

   plotvoc <- ggplot(A, aes(x = datetime, y = voc_mean.val))+
    geom_line(size = 1)+
    ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
    geom_ribbon(aes(ymax = voc_high.val, ymin = voc_low.val),
                alpha = 0.2, color = NA, fill = 'orange')+
    labs(y = 'TVOC (ppb)',
         x = "Date",
         title = paste("TVOCs - Average of Daily Values for all Homes)"))+
    coord_cartesian(ylim = c(0, 1200))+
    theme_bw()+
    theme(plot.title = element_text(hjust = 0.5),
          title = element_text(size = 18),
          axis.text = element_text(size = medium),
          strip.text = element_text( size = large),
          axis.title = element_text(size = large))+
    geom_point(size = 1)+
         facet_wrap(~location)+
          ##for extra space between facets
    theme(panel.spacing = unit(1, "lines"),
          strip.background =element_blank())
  
}
plotpm
plotvoc

```

-----


# Comparing variation between rooms

```{r function_room_comparison}


# function to compare diurnal trends of indoor rooms
# for specified metric
room.compare <- function(metric, data = omni_hourly) {
  
  # make data for plots
a <- data %>%
  select(home, location, datetime, all_of(metric), energy_cluster) %>%
  filter(location %in% c('living', 'kitchen', 'bedroom'))

# then find diurnal means and sd for each room
locations <- time.table(a,
                       'hour', metric, groupers = c('home','location'))

# find overall diurnal means and sd for pooled 
avg <- time.table(a,
                       'hour', metric, groupers = c('home'))

# join dataframes together
compare_df <- full_join(
  locations,
  avg %>% select(home, hour, overall_mean = mean.val),
  by = c('hour', 'home')) %>%
  # subtract the overall mean from each of the room mean and interval values
  mutate(mean = mean.val-overall_mean, high = high.val-overall_mean,
         low = low.val-overall_mean)

  # define plot y limits based on metric
  y_limits <- case_when(
        metric == 'pm25' ~ pm25_diff_lim,
        metric == 'voc' ~ voc_diff_lim,
        metric == 'co2' ~ co2_diff_lim,
        metric == 'temp' ~ temp_diff_lim,
        metric == 'humid' ~ humid_diff_lim,
        metric == 'lux' ~ lux_diff_lim,
        metric == 'noise' ~ noise_diff_lim)
  
  # set title depending on metric
     if(metric == 'pm25') metric_title <- expression(paste('PM'[2.5], ' Deviation from Pooled Mean'))
   if(metric == 'co2') metric_title <- expression(paste('CO'[2], ' Deviation from Pooled Mean'))
   if(metric == 'voc') metric_title <- 'TVOC Deviation from Pooled Mean'
   if(metric == 'temp') metric_title <- 'Temperature Deviation from Pooled Mean'

  ggplot(compare_df, aes(x = hour, y = mean, color = location))+
    geom_line( size = 1)+
    labs(y = 'Room Mean - Pooled Mean',
         x = "Hour of Day",
         title = metric_title)+
    scale_x_continuous(limits = c(0,24),
                       breaks = c(0,6,12,18),
                       labels = c('12am', '6am','12pm', '6pm'),
                       expand = c(0,0))+
    theme_bw()+
    coord_cartesian(ylim = y_limits)+ # defined in beginngin of function
    theme(plot.title = element_text(hjust = 0.5))+
    theme(
            title = element_text(size = small),
          axis.text = element_text(size = small-1),
          strip.text = element_text( size = small),
          axis.title = element_text(size = small),
          legend.text = element_text(size = small-1),
          legend.title = element_text(size = small)
          )+
    geom_point(size = 1)+
          ##for extra space between facets
    theme(panel.spacing = unit(1, "lines"),
          strip.background =element_blank())+
   facet_wrap(vars(home), ncol = 5)+
   geom_hline(yintercept = 0, linetype = 'dashed')+
     scale_color_manual(
       values = room_colors,
              breaks = room_breaks,
       labels = room_labels,
       name = 'Room')
  # use below lines if using error ribbon
   # geom_ribbon(aes(ymax = high, ymin = low, fill = location),
   #                  alpha = 0.2, color = NA)+
   #      scale_fill_manual(
   #     values = room_colors,
   #            breaks = room_breaks,
   #     name = 'Room')
    
    
    # ggsave(paste0('room_compare_',metric, '_', Sys.Date(),'.pdf'), plot = a ,
    #        width = 10.5, height = 8, units = 'in')
  
  
}

# # test for one metric
# room.compare('voc')



```

## For one home/metric

```{r plot_room_comparison_example, fig.height=4, fig.width = 6}
a <- omni_hourly %>% filter(home == '010')
room.compare(metric = 'pm25', data = a)
```

## FOr all homes and metrics

```{r plot_room_comparison_all, fig.height=6.5, fig.width = 10.5, results='asis'}

a <- omni_hourly %>% filter( home %in% homes_no5)

# # test for one metric
# room.compare('co2', data = a)

# make comparison plots for all metrics
lapply(metrics_all, function(x_metric) {
  a <- room.compare(metric = x_metric, data = a)
  print(a)
  # insert page break between plots
  cat("\n\n\\pagebreak\n")
})
```

