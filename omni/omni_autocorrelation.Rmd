---
title: "omni_autocorrelation"
author: "Andrew Purgiel"
date: "1/13/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

```{r}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra) #for making ggplot autocorrelation plots

```


```{r data_import}

export_date <- '2021-06-07'

##Import CSV with Real Time Data
rtdata<- read_csv(paste0('../output/omni_clean/OMNIdata_clean/',
                         'omni_all_locations_', export_date, '.csv'))


```


```{r define_functions}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}




##Define an autocorrelation plot function in ggplot

###Make acf function in ggplot
##from: https://stackoverflow.com/questions/28857241/r-combine-plots-that-use-parmfrow-internally
ggacf <- function(x, ci=0.95, type="correlation",
                  xlab="Lag", ylab=NULL,
                  ylim=NULL, main=NULL,
                  ci.col="blue", lag.max=NULL) {
  
  x <- as.data.frame(x)
  
  x.acf <- acf(x, plot=F, lag.max=lag.max, type=type)
               
               ##if missing a value, continue calculation
               ##with line below in acf function
  
               # na.action = na.pass)
  
  ci.line <- qnorm((1 - ci) / 2) / sqrt(x.acf$n.used)
  
  d.acf <- data.frame(lag=x.acf$lag, acf=x.acf$acf)
  
  g <- ggplot(d.acf, aes(x=lag, y=acf)) +
    geom_hline(yintercept=0) +
    geom_segment(aes(xend=lag, yend=0)) +
    geom_hline(yintercept=ci.line, color=ci.col,
               linetype="dashed") +
    geom_hline(yintercept=-ci.line, color=ci.col,
               linetype="dashed") +
    theme_bw() +
    # xlab("Lag") +
    ggtitle(ifelse(is.null(main), "", main)) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          plot.title = element_text(hjust = 0.5))
  #   if (is.null(ylab))
  #     ylab(ifelse(type=="partial", "PACF", "ACF"))
  # else
  #   ylab(ylab)
  
  g
}




##function to count missing day values for a home/room
##in a certain time period
count.missing <- function(hm, rm, start_date, end_date, unit) {
  
    if (unit == 'hour') {
      #define date column as all hours
  date_col <-
    seq(as.POSIXct(start_date, tz = 'UTC'), as.POSIXct(end_date, tz = 'UTC'),
        dhours(1))%>%
    as.data.frame() %>%
    rename('date' = '.')
  
  data <- hourly
  

    }
  
  if (unit == 'day') {
          #define date column as all days
    date_col <- 
    seq(as.POSIXct(start_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      as.POSIXct(end_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      ddays(1)) %>%
    as.data.frame() %>%
    rename('date' = '.')
    
    data <- daily
  
  }
  
      a<- data %>%
    filter(home == hm, room == rm) %>%
    right_join(date_col) %>%
    select('pm25') %>%
    is.na() %>%
    sum()
      
  return(a)
}



##function to make acf plot for a given room and home and metric
##that also includes all date/times within sampling time period
##gaps in dates will not be ignored
acf.plot.nomiss <- function (hm, rm,
                      metric, lag.max,
                      start_date, end_date, unit,
                      simple = FALSE) {
    
  if (unit == 'hour') {
      #define date column as all hours
  date_col <-
    seq(as.POSIXct(start_date, tz = 'UTC'), as.POSIXct(end_date, tz = 'UTC'),
        dhours(1))%>%
    as.data.frame() %>%
    rename('date' = '.')
  
  data <- hourly
  title <- 'hourly'

    }
  
  if (unit == 'day') {
          #define date column as all days
    date_col <- 
    seq(as.POSIXct(start_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      as.POSIXct(end_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      ddays(1)) %>%
    as.data.frame() %>%
    rename('date' = '.')
    
    data <- daily
    title <- 'daily'

  }
  
  #make title just home number if simple == TRUE
  title <- if_else(simple == TRUE, hm,
                                    paste(hm, title, metric))
   ##Plot data
    ##tryCatch to bypass plots that dont have data
    tryCatch(data %>%
               filter(home == hm, room == rm) %>%
               
               ##instead, define hour col between first and last date
               ##of the home/room specific data?
               right_join(date_col) %>%
               select(metric) %>%
               ggacf(lag.max = lag.max,
                     main = title),
             
             ##return NULL if there is an error
             ##due to no data for a home or room
             error = function(e) NULL)


  
}




###########

acf.grid.nomiss <- function(hms, rm, metric, lag.max,
                                start_date, end_date, unit,
                     ncol = 5) {
  
  
  plots <- lapply(hms, acf.plot.nomiss,
                  rm = rm, metric = metric,
                  lag.max = lag.max,
                  start_date = start_date, end_date = end_date,
                  unit = unit, simple = TRUE)
  
  
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  if (unit == 'hour') {title <- 'hourly'}
    if (unit == 'day') {title <- 'daily'}

  
  do.call('grid.arrange', c(plots, top = paste(rm, title, metric,
                                               as.POSIXct(start_date,
                                                          format = "%Y-%m-%d",
                                                          tz = 'UTC'), 'to',
                                               as.POSIXct(end_date,
                                                          format = "%Y-%m-%d",
                                                          tz = 'UTC')),
                            ncol = ncol))
  
}




#define list of homes for analysis
home_num <- home.list(1:16)






# test variables
metric <- 'pm25'
rm <- 'living'
lag.max <- 7
hms <- home.list(c(1:7))
unit <- 'day'


```

# Autocorrelation Raw Values

```{r autocorrelation, message= FALSE}



################Avoid claculation of AC if there are missing values



 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')





# hourly
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')


```


# Autocorrelation Log-Transformed Values

```{r autocorrelation_log, message= FALSE}



################Avoid claculation of AC if there are missing values



 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')




# hourly log-transformed
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')


# daily log-transformed
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')


# ####separate homes by sELA
# ##low_sELA homes
# acf.grid.nomiss(hms = low_sela, rm = 'living',
#                     metric = 'pm25',  lag.max = 48,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')
# 
# ##high sELA homes
# acf.grid.nomiss(hms = high_sela, rm = 'living',
#                     metric = 'pm25',  lag.max = 48,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')

```



# Autocorrelation for different time lengths

  * (subset of homes for comparibility)

```{r autocorrelation_time_lengths, message = FALSE}

# deinfe list of homes that have available data for given data range
 homes_available <- 
  sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour') %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)


 

#make temporary definitions of data to preserve it for the rest of code chunks
hourly_original <- hourly
daily_original <- daily


#filter out certain homes

hourly <- hourly_original %>%
  filter(home %in% homes_available)

daily <- daily_original %>%
  filter(home %in% homes_available)



# ## hourly bewteen two date ranges
# 
# a<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')
# 
# b<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-7 00:00:00',
#                 unit = 'hour')
# 
# c<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-11-30 00:00:00',
#                 unit = 'hour')
# 
# d<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-11-23 00:00:00',
#                 unit = 'hour')
# 
# plots <- list(a,b, c, d)
# 
# do.call('grid.arrange', c(plots, ncol = 2))




## daily bewteen two date ranges
# PM2.5

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-11-30 00:00:00',
                unit = 'day')
plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


## daily bewteen two date ranges
# VOC

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-11-30 00:00:00',
                unit = 'day')
plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))




#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original



```


# Autocorrelation for different time periods

  * (subset of homes for comparibility)

```{r autocorrelation_seasonal, message = FALSE}

 sapply(home_num, count.missing, rm = 'living',
       '2020-9-15 00:00:00',
       '2020-10-15 00:00:00',
       unit = 'hour')

 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')
 
 start_1 <- '2020-11-15 00:00:00'
  end_1 <- '2020-12-15 00:00:00'
   start_2 <- '2020-9-15 00:00:00'
  end_2 <- '2020-10-15 00:00:00'

 
  
  
#make temporary definitions of data to preserve it for the rest of code chunks
hourly_original <- hourly
daily_original <- daily
  
  
  

######################### hourly

unit_temp <- 'hour'

#deinfe list of homes that have available data for given data range
 homes_available1 <-
  sapply(home_num, count.missing, rm = 'living',
       start_1, end_1,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)

 #match with available homes from another date range
 homes_available <- sapply(home_num, count.missing, rm = 'living',
       start_2, end_2,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0 & home %in% homes_available1) %>%
  pull(home)



#filter out certain homes

hourly <- hourly_original %>%
  filter(home %in% homes_available)





## hourly bewteen two date ranges

# PM
a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


# VOC

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))

#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original







######################### daily

unit_temp <- 'day'

#deinfe list of homes that have available data for given data range
 homes_available1 <- 
  sapply(home_num, count.missing, rm = 'living',
       start_1, end_1,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)
 
 #match with available homes from another date range
 homes_available <- sapply(home_num, count.missing, rm = 'living',
       start_2, end_2,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0 & home %in% homes_available1) %>%
  pull(home)
 
 

#filter out certain homes

daily <- daily_original %>%
  filter(home %in% homes_available)





## daily bewteen two date ranges
# PM2.5

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


# VOC
a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))

#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original



```

# Ensure that the starting point does not affect autocorrelation

```{r starting_point, echo = TRUE}

# define 2 sequences, one that is translated by a value of pi/12
x1 <- seq(0,4*pi, pi/4)
x2 <- seq(pi/4,4*pi + pi/4, pi/4)

# take sine of both sequences
# simulating if we started calculating acf for a time series at 3am as opposed to 12 am
# or tuesday as opposed to wednesday (assuming the pattern repeats)
y1 <- sin(x1)
y2 <- sin(x2)

acf1<- acf(y1)
acf2<-acf(y2)




```
