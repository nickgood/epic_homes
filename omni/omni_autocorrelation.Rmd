---
title: "omni_autocorrelation"
author: "Andrew Purgiel"
date: "1/13/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  # fig.path = 'figures/',
  eval = FALSE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

```{r}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra) #for making ggplot autocorrelation plots

```


```{r data_import}

export_date <- '2021-06-07'

##Import CSV with Real Time Data
omni_data<- read_csv(paste0('../output/omni_clean/',
                         'omni_all_locations_', export_date, '.csv'))


```


```{r functions_misc}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}

```

```{r define_variables}


#define homes for analysis
homes_all <- home.list(c(1:4, 7:16))

# define indoor rooms
locations_indoor <- c('living', 'bedroom', 'kitchen')

# define homes that have data for all indoor rooms (if needed)
homes_avail <- homes_all[-2]

# define metrics for acf testing
metrics_all <- c('pm25', 'voc', 'co2', 'temp', 'humid')

#define sizes for plot text
xsmall <- 2
small <- 4
medium <- 12
large <- 16

```


```{r function_count_missing_values, include = FALSE, eval = FALSE}

##function to count missing day values for a home/room
count.missing <- function(data, hm, loc, metric,
                          # if start/end date not specified, first and last
                          # date for specified home/location used
                          start_date = '1971-01-01 00:00:00',
                          end_date = '2099-01-01 00:00:00',
                          unit = 'day') {
  
  
    if (unit == 'hour') {

  avg_data <- data %>%
  filter(home == hm & location == loc) %>%
    filter(datetime > ymd_hms(start_date) & datetime < ymd_hms(end_date)) %>%
  mutate(date = floor_date(datetime, unit = 'hours')) %>%
  group_by(date) %>%
  summarize_if(is.numeric, list(~mean(., na.rm = TRUE))) %>%
  ungroup() %>%
        complete(date = seq(ymd_hms(min(date)), ymd_hms(max(date)),
        dhours(1)))

  

    }
  
  if (unit == 'day') {

          avg_data <- data %>%
  filter(home == hm & location == loc) %>%
                filter(datetime > ymd_hms(start_date) & datetime < ymd_hms(end_date)) %>%
  mutate(date = floor_date(datetime, unit = 'days')) %>%
  group_by(date) %>%
  summarize_if(is.numeric, list(~mean(., na.rm = TRUE))) %>%
  ungroup() %>%
    complete(date = seq(min(date), max(date), by="day"))

  }
  
      a<- avg_data %>%
    select(all_of(metric)) %>%
    is.na() %>%
    sum()
      
  return(a)
}

```

```{r count_missing_values, include = FALSE, eval = FALSE}


# see which homes/locations do not have missing daily average values
 sapply(homes_all, count.missing,
        loc = 'living',
        data = omni_data,
       metric = 'pm25')

```

```{r create_dfs}

# all homes/locations in one dataframe
# with missing dates put in as NA values
## daily
omni_daily_data <- omni_data %>%
  mutate(date = floor_date(datetime, unit = 'days')) %>%
  group_by(home, location, date) %>%
  summarize_if(is.numeric, list(~mean(., na.rm = TRUE))) %>%
    complete(date = seq(min(date), max(date), by="day")) %>%
  ungroup()%>%
  mutate(date = ymd(date)) %>%
  arrange(home, location, date)


# # to insert NA rows between each group (could modify to add multiple NAs)
# # from https://stackoverflow.com/questions/43403282/add-row-in-each-group-using-dplyr-and-add-row
# indices <- seq(nrow(a)) %>%
#     split(group_indices(a, home, location)) %>%
#     map(~c(.x, rep(NA,10))) %>% # add in ten rows after each group
#     unlist()

# ## hourly
# omni_hourly_data <- omni_data %>%
#   mutate(date = floor_date(datetime, unit = 'hours')) %>%
#   group_by(home, location, date) %>%
#   summarize_if(is.numeric, list(~mean(., na.rm = TRUE))) %>%
#   complete(date = seq(ymd_hms(min(date)), ymd_hms(max(date)),
#                       dhours(1))) %>%
#   ungroup()%>%
#   arrange(home, location, date)


```

```{r add_clusters}

# classify homes into "types" based on cluster pattern
homes_tier3<-home.list(c(1,2,7,9,12)) # ac-shoulder-heat
homes_tier2<-home.list(c(4,10,11,13,15)) # shoulder-heat (sometimes second shoulder)
homes_tier1<-home.list(c(6,8,14))

omni_daily_data<- omni_daily_data %>%
  mutate(home_type = case_when(
    home %in% homes_tier3 ~ 'tier3',
    home %in% homes_tier2 ~ 'tier2',
    home %in% homes_tier1 ~ 'tier1',
    TRUE ~ 'unclassified'))

energy_cluster_df<- tribble(~home, ~cluster_type,
                            ~start_date, ~end_date,
                     '001', 'ac', '2020-08-01', '2020-10-01',
                     '001', 'shoulder', '2020-10-02', '2020-12-02',
                     '001', 'heat', '2020-12-03', '2021-05-23',
                     '002', 'ac', '2020-08-01', '2020-08-27',
                     '002', 'shoulder', '2020-08-28', '2020-10-07',
                     '002', 'heat', '2020-10-08', '2021-05-23',
                     '004', 'shoulder', '2020-08-10', '2020-10-12',
                     '004', 'heat', '2020-10-13', '2021-05-23',
                     '007', 'ac', '2020-08-01', '2020-09-04',
                     '007', 'shoulder', '2020-09-05', '2020-10-12',
                     '007', 'heat', '2020-10-13', '2021-05-23',
                     '009', 'ac', '2020-08-01', '2020-09-23',
                     '009', 'shoulder', '2020-09-24', '2020-10-31',
                     '009', 'heat', '2020-11-01', '2021-05-23',                     
                     '010', 'heat', '2020-12-02', '2021-05-23',
                     '011', 'none', '2020-08-01', '2020-12-01',
                     '011', 'heat', '2020-12-02', '2021-05-23',
                     '012', 'ac', '2020-08-01', '2020-09-26',
                     '012', 'shoulder', '2020-09-27', '2020-11-07',
                     '012', 'heat', '2020-11-08', '2021-05-23',
                     '013', 'none_1', '2020-08-01', '2020-11-07',
                     '013', 'heat', '2020-11-08', '2021-03-31',
                     '013', 'none_2', '2021-04-01', '2021-05-23',
                     '015', 'none_1', '2020-08-01', '2020-11-23',
                     '015', 'heat', '2020-11-24', '2021-03-28',
                     '015', 'none_2', '2021-03-29', '2021-05-23',
) %>%
  mutate(across(start_date, ymd), across(end_date, ymd))



# make an empty column to fill with cluster function
omni_daily_data$energy_cluster <- NA


# # using lapply
# lapply('001', function(x_home) {
#   
#   lapply(
#     # apply the function to all the energy clusters for a given home
#     c(1:length(which(energy_clusters$home == hm))),
#      function(cluster_type_index) {
#       
#       omni_daily_data$energy_cluster[
#         which(omni_daily_data$home == x_home &
#                 between(omni_daily_data$date,
#                         energy_clusters[which(energy_clusters$home == x_home)[cluster_type_index],
#                                         'start_date'][[1]],
#                         energy_clusters[which(energy_clusters$home == x_home)[cluster_type_index],
#                                         'end_date'][[1]])
#         )
#       ]<- energy_clusters[which(energy_clusters$home == x_home)[cluster_type_index], 'type'][[1]]
#     }
#   )
# }
# )


# using for loop
#specify all homes that have specified energy clusters
homes_clustered <- levels(as.factor(energy_cluster_df$home))

for(i in 1:length(homes_clustered)) { 
  # for each home
  # identify the df matrix index of each cluster cluster_type
  cluster_type_indeces <- which(energy_cluster_df$home == homes_clustered[i])

    for(j in 1:length(cluster_type_indeces)) {
    # for each cluster type in each home in the energycluster dataframe
      # indentify the values in the data that are match the home
      # and are within the dates specified by the cluster
    omni_daily_data$energy_cluster[
      which(omni_daily_data$home == homes_clustered[i] &
              between(omni_daily_data$date,
                      energy_cluster_df[cluster_type_indeces[j],
                                      'start_date'][[1]],
                      energy_cluster_df[cluster_type_indeces[j],
                                      'end_date'][[1]])
      )
      # add the identified cluster type of each value
      # in the new column in the data
    ] <- energy_cluster_df[cluster_type_indeces[j], 'cluster_type'][[1]]
  }
}

# convert any NA clusters to "unclassified"
omni_daily_data <- omni_daily_data %>%
  mutate(energy_cluster = if_else(is.na(energy_cluster), 'unclassified', energy_cluster))

# other possible method?
# https://stackoverflow.com/questions/35636315/replace-values-in-a-dataframe-based-on-lookup-table


```

```{r ts_grid_function, include = FALSE}
#function to put plots in a grid
ts.grid <- function(plots, title,
                     y_val = NULL, ncol = 4, nrow = 4) {
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  do.call('grid.arrange', c(plots, top = title, left = y_val,
                            ncol = ncol, nrow = nrow))
  
}

# NOTE, if there are no homes with valid data in selection (plots <- NULL)
# the function will return the error: 
### Error in unit(rep(1, nrow), "null") : 'x' and 'units' must have length > 0

```


```{r stationarity}
# check stationarity before doing acf calcs and plots


# make time series plot for all available sensors
map(
  homes_avail, function(x_home) {
    map(
      locations_indoor, function(x_location){
        
        ggplot(omni_daily_data %>% filter(home == x_home & location == x_location),
               aes(x = as.Date(date), y = pm25,
                   color=case_when(grepl('heat', energy_cluster)~ 'red',
                                   energy_cluster == 'ac' ~ 'blue',
                                   grepl('none|shoulder', energy_cluster)~ 'darkgreen',
                                   energy_cluster == 'unclassified' ~ 'black')))+
          scale_color_identity(name = "Cluster",
                               breaks = c("blue", "darkgreen", "red", "black"),
                               labels = c("AC", "Shoulder", "Heat", "Unclassified"),
                               guide = "legend")+

          geom_line()+
          ggtitle(paste(x_home, x_location))
        
      }
    )
  }
)


# make time series plot for all available sensors
map(
  homes_avail, function(x_home) {
    map(
      locations_indoor, function(x_location){
        
        ggplot(omni_daily_data %>% filter(home == x_home & location == x_location),
               aes(x = as.Date(date), y = pm25,
                   color=case_when(grepl('heat', energy_cluster)~ 'red',
                                   energy_cluster == 'ac' ~ 'blue',
                                   grepl('none|shoulder', energy_cluster)~ 'darkgreen',
                                   energy_cluster == 'unclassified' ~ 'black')))+
          scale_color_identity(name = "Cluster",
                               breaks = c("blue", "darkgreen", "red", "black"),
                               labels = c("AC", "Shoulder", "Heat", "Unclassified"),
                               guide = "legend")+

          geom_line()+
          ggtitle(paste(x_home, x_location))
        
      }
    )
  }
)


hm <- '010'
loc <- 'bedroom'
metric <- 'temp'

# for one home
ggplot(omni_daily_data %>% filter(home == hm & location == loc),
               aes(x = as.Date(date), y = UQ(as.name(metric)),
                   color=case_when(grepl('heat', energy_cluster)~ 'red',
                                   energy_cluster == 'ac' ~ 'blue',
                                   grepl('none|shoulder', energy_cluster)~ 'darkgreen',
                                   energy_cluster == 'unclassified' ~ 'black')))+
          scale_color_identity(name = "Cluster",
                               breaks = c("blue", "darkgreen", "red", "black"),
                               labels = c("AC", "Shoulder", "Heat", "Unclassified"),
                               guide = "legend")+
          geom_line()+
          ggtitle(paste(hm, loc))

ggplot(omni_daily_data %>% filter(home == hm & location == loc),
       aes(x = as.Date(date), y = UQ(as.name(metric))))+
  geom_line()+
  ggtitle(paste(hm, loc))



# # plot differenced time series
# diff_data <- omni_daily_data %>%
#   filter(home == hm & location == loc) %>%
#   mutate(diff = c(NA, diff(pull(., all_of(metric),1))))
# 
# 
# 
# diff_data <- omni_daily_data %>%
#   filter(home == hm & location == loc) %>%
#   # make column of metric differenced with itself by one day
#   mutate(diff = c(NA, diff(pull(., all_of(metric),1))))
#   # # set up for faceting
#   # pivot_longer(cols = c(all_of(metric), diff),
#   #              names_to = 'data_set', values_to = 'value') %>%
#   # mutate(data_set = if_else(data_set == 'diff',
#   #                           paste0(quo_name(metric), '_diff'),
#   #                           data_set))
# 
# ggplot(diff_data,
#        aes(x = as.Date(date), y = value))+
#   geom_line()+
#   ggtitle(paste(hm, loc))+
#   facet_wrap(vars(data_set), scales = 'free')
# 
# diff_data2 <- diff_data[-c(1,101),]
# 
# # plot results for one location and metric
# lapply('002', function(x) {
#   ggacf(hm = x,
#         data = diff_data2,
#         loc = 'living', lag_max_plot = 14, metric = 'diff',
#   )[['plot']]
# }
# )


```



```{r ggacf_function, include= FALSE}

# # variables or testing
# data <- omni_daily_data
# hm <- '003'
# loc <- 'living'
# metric <- 'pm25'
# lag.max <- 14

##Define an autocorrelation plot function in ggplot

###Make acf function in ggplot
##from: https://stackoverflow.com/questions/28857241/r-combine-plots-that-use-parmfrow-internally

ggacf <- function(data,  hm, loc, lag_max_plot, metric,
                  cluster = NULL,
                       ci=0.95, type="correlation",
                       xlab="Lag", ylab=NULL,
                       ylim=NULL, simple = FALSE,
                       ci.col="blue") {

    x <- data %>% 
    filter(home == hm & location == loc)
  
  x<- if(!is.null(cluster)) {
    # filter by cluster if cluster is specified
    x %>% 
      filter(energy_cluster == cluster) %>%
      pull(all_of(metric))
    }else {
    x %>% 
      pull(all_of(metric))
    }

  if(length(x) == 0) return()
  
  # count days in monitoring period with available data
  days_avail <- sum(!is.na(x))
  
  # count percentage of missing values
  missing <- sum(is.na(x))/length(x)*100
  
  # set limit of how many lags for which the function performs calculations
  lag_max_calc <- if_else(length(x)<=31, length(x)-1, 30)
  
  x_acf <- acf(x, plot=F, lag.max=lag_max_calc, type=type,
               
               ##if missing a value, continue calculation
               ##with line below in acf function
               na.action = na.pass
  )
  
  # find actual n value (doesn't count when one of the data in a pair is NA)
  lags <- c(1:lag_max_calc)
  
  lag_counts <- map(lags, function(x) {
    data %>%
      filter(home == hm & location == loc)%>%
      pull(all_of(metric)) %>%
      diff(lag = x) %>%
      is.na() %>%
      `!` %>% #count how many are not NA
      sum()
  }
  ) %>% 
    unlist() %>%
    as.data.frame()%>%
    rename('n_lag'= '.') %>%
    mutate(lag = lags)
  
  df_acf <- data.frame(lag=x_acf$lag, acf=x_acf$acf,
                       n_lag = if(type == 'correlation') {
                         c(NA,lag_counts$n_lag)
                       } else if(type == 'partial') lag_counts$n_lag ) %>%
    mutate(
      # from UMich Notes, Sales et al. 1980
      ci_high = -qnorm((1-ci)/2)/sqrt(n_lag),
      ci_low = qnorm((1-ci)/2)/sqrt(n_lag)
      
    )
  
  #plot
  plot <- ggplot(df_acf, aes(x=lag, y=acf)) +
    geom_hline(yintercept=0) +
    geom_segment(aes(xend=lag, yend=0)) +
    geom_line(aes(x = lag, y = ci_high),
              linetype = 'dashed', color = ci.col)+
    geom_line(aes(x = lag, y = ci_low),
              linetype = 'dashed', color = ci.col)+
    geom_text(aes(x = lag, y = acf+0.05, label = n_lag),
              size = xsmall)+ # annotate w/ n used to calculate acf for each lag
    theme_bw() +
    xlab("Lag") +
    ggtitle(if_else(simple == TRUE,
                    paste(hm, '*missing', signif(missing,3), '%'),
                    paste(hm, loc, metric, cluster))) +
    {if (simple != TRUE) {
      annotate( 'text', x = Inf, y = Inf, hjust = 1, vjust = 1,
              label = paste("*missing", signif(missing,3), "% of daily values\n",
                            "in home sampling period"), size = small)}}+
    coord_cartesian(xlim=c(0, lag_max_plot), ylim = c(-0.5,1))+
    {if(simple == TRUE) {
      theme(axis.title = element_blank(),
          # axis.text.x = element_blank(),
          axis.ticks = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.border = element_blank(),
          plot.title = element_text(hjust = 0.5))}}+
    if (is.null(ylab))
      ylab(ifelse(type=="partial", "PACF", "ACF"))
  else
    ylab(ylab)
  
  # find first lag point when acf goes inside confidence intervals
  a <- df_acf %>%
    filter(acf <= ci_high
           & acf >= ci_low
    ) %>%
    pull(lag)
  
  lag_signif <- ifelse(length(a)>0, min(a), Inf) %>%
    as.data.frame() %>%
    rename('lag_signif' = '.') %>%
    mutate(home = hm, location = loc, metric = metric,
           days_avail = days_avail, missing_pct = missing, acf_type = type,
           energy_cluster = cluster)
  
  return(list('lag_signif' = lag_signif, 'plot' = plot))
}

# # test for one home, loc, metric
# lapply('002', ggacf,
#        data = omni_daily_data, loc = 'living', lag_max_plot = 10,
#        metric = 'pm25', simple= TRUE)
```


```{r test_acf_data_resolution_effect, eval = FALSE}
# is the point at which data crosses conf_int
# affected by resolution of data?

# daily
acf(omni_daily_data %>%
      filter(home == '002' & location == 'living') %>%
      select(pm25),
    na.action = na.pass, lag.max = 10)

map(homes_all, function (x){
  acf(omni_daily_data %>% filter(home == x & location == 'living') %>%select(pm25),
      na.action = na.pass,
      lag.max = 48)
})

# hourly
acf(omni_hourly_data %>% filter(home == '002' & location == 'living') %>%select(pm25),
    na.action = na.pass, lag.max = 240)

map(homes_all, function (x){
  acf(omni_hourly_data %>% filter(home == x & location == 'living') %>%select(pm25),
                             na.action = na.pass,
      lag.max = 240)
  })

```

```{r test_ggacf_to_acf_func, eval = FALSE}
# does my function compare to the default acf, just with different conf_int?

acf(omni_daily_data %>%
      filter(home == '002' & location == 'living') %>%
      select(pm25),
    na.action = na.pass, lag.max = 10)

lapply(homes_all, ggacf,
       data = omni_daily_data, loc = 'living', lag_max_plot = 10, metric = 'pm25')


  
```

```{r ggacf_grid_function, include = FALSE}
#function to put plots in a grid
acf.grid <- function(plots, title,
                     y_val = 'ACF', ncol = 4, nrow = 4) {
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  do.call('grid.arrange', c(plots, top = title, left = y_val,
                            ncol = ncol, nrow = nrow))
  
}

# NOTE, if there are no homes with valid data in selection (plots <- NULL)
# the function will return the error: 
### Error in unit(rep(1, nrow), "null") : 'x' and 'units' must have length > 0

```





# Examples of autocorrelation plots  

```{r ggacf_grid_plots_no_clusters, fig.width=8, fig.height=4.5}

# plots for all homes, locations, and metrics (no clusters)

    # all locs/metrics  
      lapply(locations_indoor, function(x_location) {
        
        lapply(metrics_all, function(x_metric) {
          
          lapply(homes_avail, function(x_home) {
            ggacf(hm = x_home,
                  data = omni_daily_data,
                  loc = x_location, lag_max_plot = 30, metric = x_metric,
                  simple = TRUE
            )[['plot']]
          }
          ) %>%
            acf.grid(title = paste(x_location, x_metric, 'no clusters'))
        }
        )
      }
      )

# # not in grid
#   plots <- lapply(metrics_all, function(x_metric) {
#     
#     lapply(locations_indoor, function(x_location) {
#       
#       lapply(homes_avail, function(x_home) {
#         ggacf(hm = x_home,
#               data = omni_daily_data,
#               loc = x_location, lag_max_plot = 14, metric = x_metric
#         )[['plot']]
#       }
#       ) 
#     }
#     ) 
#   }
#   )

# # no grid
#   plots <- lapply(metrics_all, function(x_metric) {
#     
#     lapply(locations_indoor, function(x_location) {
#       
#       lapply(homes_avail, function(x_home) {
#         ggacf(hm = x_home,
#               data = omni_daily_data,
#               loc = x_location, lag_max_plot = 14, metric = x_metric
#         )[['plot']]
#       }
#       ) 
#     }
#     ) 
#   }
#   )

# one location/metric at a time
# loc <- 'living'
# metric <- 'pm25'
# 
#       lapply(homes_avail, function(x_home) {
#         ggacf(hm = x_home,
#               data = omni_daily_data,
#               loc = loc, lag_max_plot = 30, metric = metric,
#               simple = TRUE
#         )[['plot']]
#       }
#       ) %>%
#   acf.grid(title = paste(loc, metric, 'no clusters'), ncol = 4)
#       
# metric <- 'voc'
# 
# 
#       lapply(homes_avail, function(x_home) {
#         ggacf(hm = x_home,
#               data = omni_daily_data,
#               loc = loc, lag_max_plot = 30, metric = metric,
#               simple = TRUE
#         )[['plot']]
#       }
#       ) %>%
#   acf.grid(title = paste(loc, metric, 'no clusters'), ncol = 4)
#       
#       metric <- 'voc'
# 
#       
# loc <- 'living'
# metric <- 'pm25'
#       lapply(homes_avail, function(x_home) {
#         ggacf(hm = x_home,
#               data = omni_daily_data,
#               loc = loc, lag_max_plot = 30, metric = metric,
#               simple = TRUE
#         )[['plot']]
#       }
#       ) %>%
#   acf.grid(title = paste(loc, metric, 'no clusters'), ncol = 4)
      
    

```

## for some homes, acf stops decreasing (especially pm25), likely due to non-stationarity of data  
## will shorter time periods avoid this?  

```{r test_ggacf_n_sample, fig.width=8, fig.height=4.5}
# how does the total amount of days sampled affect the plot?

# plot results for one location and metric at each home

# all dates
loc <- 'living'
metric <- 'pm25'

      lapply(homes_avail, function(x_home) {
        ggacf(hm = x_home,
              data = omni_daily_data,
              loc = loc, lag_max_plot = 30, metric = metric,
              simple = TRUE
        )[['plot']]
      }
      ) %>%
  acf.grid(title = paste(loc, metric, 'all dates'))

      

            
# multpile smaller date ranges

                        date_ranges <- list(c('2020-11-01', '2020-12-31'),
                                c('2021-01-01', '2021-02-28'),
                                c('2021-03-01', '2021-04-30'))
                        
                 lapply(date_ranges, function(x_date_range) {
                       
                   # date_range <- unlist(x_date_range)
                   # another month
            lapply(homes_all, function(x_home) {
        ggacf(hm = x_home,
              data = omni_daily_data %>%
          filter(date>= ymd(x_date_range[1]) & date <=ymd(x_date_range[2])),
              loc = loc, lag_max_plot = 30, metric = metric,
              simple = TRUE
        )[['plot']]
      }
      ) %>%
  acf.grid(title = paste(loc, metric,
                            month(x_date_range[1], label = TRUE, abbr = TRUE),
                         '-',
                         month(x_date_range[2], label = TRUE, abbr = TRUE))
           )   
                 }
                 )

```

## shorter time periods due seem to avoid the slow decrease, see home 002 only has slight issue in one time period

```{r ggacf_grid_plots_with_clusters, fig.width=8, fig.height=4.5}
# plots for all homes, locations, and metrics (with clusters)
  lapply(metrics_all, function(x_metric) {
    
    lapply(locations_indoor, function(x_location) {
      
      lapply(omni_daily_data %>%
                 pull(energy_cluster) %>%
                 as.factor() %>% levels(),
               function(x_cluster) {
                 
      lapply(homes_avail, function(x_home) {
        
        # if cluster exists for given house, return plot
                if (x_cluster %in%
                    (omni_daily_data %>%
                    filter(home == x_home) %>%
                    pull(energy_cluster) %>%
                    as.factor() %>% levels())
                ) { 
                  ggacf(hm = x_home,
              data = omni_daily_data,
              loc = x_location, lag_max_plot = 14, metric = x_metric,
              cluster = x_cluster
        )[['plot']]
                  } else{
                    # if cluster does not exist for home, return NULL
                    NULL
                  }
               }
      ) %>%
          acf.grid(title = paste(x_location, x_metric, x_cluster)) 
      }
      ) 
    }
    ) 
  }
  )



```

## Calculate how many lags (days) it takes for pollutant/metric to
## not be significantly autocorrelated


```{r lag_dataframes}

# return data for all homes, locations, and metrics (no clusters)
acf_lags_no_cluster <- 
  lapply(metrics_all, function(x_metric) {
    
    lapply(locations_indoor, function(x_location) {
      
      lapply(homes_avail, function(x_home) {
        ggacf(hm = x_home,
              data = omni_daily_data,
              loc = x_location, lag_max_plot = 14, metric = x_metric
        )[['lag_signif']]
      }
      ) %>%
        bind_rows()
    }
    ) %>%
      bind_rows()
  }
  ) %>%
  bind_rows() %>%
  mutate(energy_cluster = 'all_dates')


# return data for all homes, locations, and metrics (with clusters)
acf_lags_cluster <- 
  lapply(metrics_all, function(x_metric) {
    
    lapply(locations_indoor, function(x_location) {
      
      lapply(homes_avail, function(x_home) {
        
        lapply(omni_daily_data %>%
                 filter(home == x_home) %>%
                 pull(energy_cluster) %>%
                 as.factor() %>% levels(),
               function(x_cluster) {
                 
        ggacf(hm = x_home,
              data = omni_daily_data,
              loc = x_location, lag_max_plot = 14, metric = x_metric,
              cluster = x_cluster
        )[['lag_signif']]
               }
      ) %>%
        bind_rows()
      }
      ) %>%
        bind_rows()
    }
    ) %>%
      bind_rows()
  }
  ) %>%
  bind_rows()


# bind results into one dataframe
acf_lags <- acf_lags_cluster %>% bind_rows(acf_lags_no_cluster)
```


```{r lag_plots}

######## one metric
met <- 'pm25'

  # convert values that were infinite to above the maximum tested value
# and omit samples that have less than 21 available days
# and omit samples with a missing pct greater than 1/9


acf_lags_filter <- acf_lags %>%
  # mutate(lag_signif = if_else(is.infinite(lag_signif), 35, lag_signif)) %>%
  filter(days_avail >=21 & missing_pct <= (1/9*100))


a <- acf_lags_filter %>% 
  filter(energy_cluster %in% c('ac', 'shoulder', 'heat', 'all_dates')) %>%
  filter(metric == met)

# # look at possible effects of sample size
# ggplot(data = a , aes(x = days_avail, y = lag_signif))+
#   geom_point(aes(color = location))+
#   facet_wrap(vars(energy_cluster))


# boxplots by location
ggplot(data = a , aes(x = location, y = lag_signif))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(
    color = ifelse(is.infinite(lag_signif),
                    'red',
                    'black')
    ), height = 0)+
  facet_wrap(vars(energy_cluster))+
  ggtitle(label = paste0(met, ', lags before acf is insignficant'))+
  scale_y_continuous(oob= scales::squish_infinite)+
            scale_color_identity(name = "Insignifiance Reached within Month",
                               breaks = c("black", "red"),
                               labels = c("Yes", "No"),
                               guide = "legend")

# boxplots by location, pooled clusters
ggplot(data = a %>% filter(energy_cluster != 'all_dates') ,
       aes(x = location, y = lag_signif))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(
    color=case_when(grepl('heat', energy_cluster)~ 'red',
                    energy_cluster == 'ac' ~ 'blue',
                    grepl('none|shoulder', energy_cluster)~ 'darkgreen',
                    energy_cluster == 'unclassified' ~ 'black')
  ), height = 0)+
  ggtitle(label = paste0(met, ', lags before acf is insignficant'))+
  scale_y_continuous(oob= scales::squish_infinite)+
  scale_color_identity(name = "Cluster",
                       breaks = c("blue", "darkgreen", "red", "black"),
                       labels = c("AC", "Shoulder", "Heat", "Unclassified"),
                       guide = "legend")
          


####### compare all metrics, pooled cluster periods

a <- acf_lags_filter %>% 
  filter(energy_cluster %in% c('ac', 'shoulder', 'heat', 'all_dates'))

# boxplots by location, pooled clusters
ggplot(data = a %>% filter(energy_cluster != 'all_dates') ,
       aes(x = location, y = lag_signif))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(
    color=case_when(grepl('heat', energy_cluster)~ 'red',
                    energy_cluster == 'ac' ~ 'blue',
                    grepl('none|shoulder', energy_cluster)~ 'darkgreen',
                    energy_cluster == 'unclassified' ~ 'black')
  ), height = 0)+
  facet_wrap(vars(metric))+
  ggtitle(label = 'Lags before acf is insignficant')+
  scale_y_continuous(oob= scales::squish_infinite)+
  scale_color_identity(name = "Cluster",
                       breaks = c("blue", "darkgreen", "red", "black"),
                       labels = c("AC", "Shoulder", "Heat", "Unclassified"),
                       guide = "legend")



```



```{r ggacf_partial, eval = FALSE}

# plot results for one location and metric
lapply(homes_all, function(x) {
  ggacf(hm = x,
        data = omni_daily_data,
        loc = 'living', lag_max_plot = 14, metric = 'pm25', type = 'partial'
  )[['plot']]
}
)
```

