---
title: "omni_autocorrelation"
author: "Andrew Purgiel"
date: "1/13/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)


##Adapted from Collin Brehmer code---------------------------
list.of.packages <- c("ggthemes", "tidyverse", "lubridate", "tidyselect",
                      "googlesheets4", #for importing questionnaires from Drive
                      "ggpubr", #for normality testing
                      'gridExtra', #for making ggplot autocorrelation plots
                      'irr') #for calculating ICC

##install any packages in the above list that are not already installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

lapply(list.of.packages, library, character.only = TRUE)


#insert your email here to authorize access to questionnaire
gs4_auth(email = "apurgiel@rams.colostate.edu")

```

```{r data_import}

# CSV Data Import ---------------------------------------------------------

##Import CSV with Real Time Data
rtdata<- read_csv("./OMNIdata_clean.csv",
                  col_types = cols(
                    date = col_datetime(),
                    home = col_factor(),
                    room = col_factor(),
                    pm25 = col_number(),
                    temp = col_number(),
                    rh = col_number()), na = "NA")

##Import CSV with Real Time Data
hourly<- read_csv("./OMNIdata_hourly.csv",
                  col_types = cols(
                    date = col_datetime(),
                    home = col_factor(),
                    room = col_factor(),
                    pm25 = col_number(),
                    temp = col_number(),
                    rh = col_number()), na = "NA")


##Import CSV with Real Time Data
daily<- read_csv("./OMNIdata_daily.csv",
                  col_types = cols(
                    date = col_datetime(),
                    home = col_factor(),
                    room = col_factor(),
                    pm25 = col_number(),
                    temp = col_number(),
                    rh = col_number()), na = "NA")

##Import CSV with Real Time Data
weekly<- read_csv("./OMNIdata_weekly.csv",
                  col_types = cols(
                    date = col_datetime(),
                    home = col_factor(),
                    room = col_factor(),
                    pm25 = col_number(),
                    temp = col_number(),
                    rh = col_number()), na = "NA")


# Questionnaire Data Import -----------------------------------------------


# ##Import questionnaire Data from Google Drive
# 
# ##Appliance Questionnaire
# appq <- read_sheet("https://docs.google.com/spreadsheets/d/154vgySyseWzcUYLubFWOYqQ_IZkgckqiyEIwzFkphzY/edit?usp=sharing")
# 
# ##Home Questionnaire
# homeq <- read_sheet("https://docs.google.com/spreadsheets/d/1ZMAggLlA64uDy05lfLupGyBcbyVvEN8AbRzTmxuJpZA/edit?usp=sharing")
# 
# ## Home data from energy assessments
# adata <- read_sheet('https://docs.google.com/spreadsheets/d/12vWpqdmzIII0vEKH79xpmICUYGuzc8PjfBT2_3YjIHU/edit?usp=sharing')
# 
# 
# ##https://stackoverflow.com/questions/24459752/can-dplyr-package-be-used-for-conditional-mutating
# ##See the above link for alternative methods to this mutate
# qdata <- full_join(appq, homeq, by = c('Participant ID', 'Visit')) %>%
#   
#   ##make home column
#   ##and change certain column names to be concise
#   mutate(home = str_remove(`Participant ID`, 'P'),
#          vent_kit = `How is your kitchen ventilated?`,
#          kit_filter = `When the kitchen is IN USE, how often do you and your household use this method to ventilate your kitchen? [recirculating filter]`,
#          kit_exhaust = `When the kitchen is IN USE, how often do you and your household use this method to ventilate your kitchen? [outside exhaust]`,
#          kit_window = `When the kitchen is IN USE, how often do you and your household use this method to ventilate your kitchen? [window(s)]`,
#          kit_fan = `When the kitchen is IN USE, how often do you and your household use this method to ventilate your kitchen? [wall fan]`,
#          window_summer = `In an average week in the SUMMER, how often are your windows and blinds / shades open? [windows]`,
#          window_fall = `In an average week in the FALL, how often are your windows and blinds / shades open? [windows]`,
#          window_winter = `In an average week in the WINTER, how often are your windows and blinds / shades open? [windows]`,
#          window_spring = `In an average week in the SPRING, how often are your windows and blinds / shades open? [windows]`,
#          oven_use = `Cooking appliances [How many times do you use your oven (not including stove)?]`) %>%
# 
#   #make oven_use col ready for analysis
#   mutate(oven_use = if_else(str_detect(oven_use,
#                                        '1 per day|2 per day'), 'daily',
#                             'weekly') %>%
#            as.factor()) %>%
#   
#     ##make kitchen ventilation column
#   mutate(vent = if_else(str_detect(vent_kit, 'outside exhaust'), 'exhaust',
#                         if_else(str_detect(vent_kit, 'recirculating filter|wall fan'),
#                                 'filt_fan',
#                                 if_else(str_detect(vent_kit, 'window\\(s\\)|passive vent'),
#                                         'passive', 'none'))) %>%
#            as.factor()) %>%
#   
#   #make a column for kitchen mechanical vent use
#   mutate(
#     #sometimes/always if they answered that they at least sometimes or always
#     #use mechanical ventialtion when kitchen is in use
#     #(fan, filter, or outside exhaust)
#     #rarely/never if they never/rarely use, or don't have
#     kit_mech = if_else(str_detect(kit_filter,
#                                        'sometimes|always') |
#                               str_detect(kit_exhaust,
#                                          'sometimes|always') |
#                               str_detect(kit_fan,
#                                          'sometimes|always') ,
#                             'sometimes/always',
#                             'rarely/never') %>%
#       as.factor()) %>%
#   
#   #join with appliance data
#   full_join(adata) %>%
#   #make specific estimated leakage rate col
#   mutate(sela = ela/est_vol)
# 
# 

qdata <- read.csv(file = 'survey_data.csv')





```


```{r define_functions}

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}




##Define an autocorrelation plot function in ggplot

###Make acf function in ggplot
##from: https://stackoverflow.com/questions/28857241/r-combine-plots-that-use-parmfrow-internally
ggacf <- function(x, ci=0.95, type="correlation",
                  xlab="Lag", ylab=NULL,
                  ylim=NULL, main=NULL,
                  ci.col="blue", lag.max=NULL) {
  
  x <- as.data.frame(x)
  
  x.acf <- acf(x, plot=F, lag.max=lag.max, type=type)
               
               ##if missing a value, continue calculation
               ##with line below in acf function
  
               # na.action = na.pass)
  
  ci.line <- qnorm((1 - ci) / 2) / sqrt(x.acf$n.used)
  
  d.acf <- data.frame(lag=x.acf$lag, acf=x.acf$acf)
  
  g <- ggplot(d.acf, aes(x=lag, y=acf)) +
    geom_hline(yintercept=0) +
    geom_segment(aes(xend=lag, yend=0)) +
    geom_hline(yintercept=ci.line, color=ci.col,
               linetype="dashed") +
    geom_hline(yintercept=-ci.line, color=ci.col,
               linetype="dashed") +
    theme_bw() +
    # xlab("Lag") +
    ggtitle(ifelse(is.null(main), "", main)) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          plot.title = element_text(hjust = 0.5))
  #   if (is.null(ylab))
  #     ylab(ifelse(type=="partial", "PACF", "ACF"))
  # else
  #   ylab(ylab)
  
  g
}




##function to count missing day values for a home/room
##in a certain time period
count.missing <- function(hm, rm, start_date, end_date, unit) {
  
    if (unit == 'hour') {
      #define date column as all hours
  date_col <-
    seq(as.POSIXct(start_date, tz = 'UTC'), as.POSIXct(end_date, tz = 'UTC'),
        dhours(1))%>%
    as.data.frame() %>%
    rename('date' = '.')
  
  data <- hourly
  

    }
  
  if (unit == 'day') {
          #define date column as all days
    date_col <- 
    seq(as.POSIXct(start_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      as.POSIXct(end_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      ddays(1)) %>%
    as.data.frame() %>%
    rename('date' = '.')
    
    data <- daily
  
  }
  
      a<- data %>%
    filter(home == hm, room == rm) %>%
    right_join(date_col) %>%
    select('pm25') %>%
    is.na() %>%
    sum()
      
  return(a)
}



##function to make acf plot for a given room and home and metric
##that also includes all date/times within sampling time period
##gaps in dates will not be ignored
acf.plot.nomiss <- function (hm, rm,
                      metric, lag.max,
                      start_date, end_date, unit,
                      simple = FALSE) {
    
  if (unit == 'hour') {
      #define date column as all hours
  date_col <-
    seq(as.POSIXct(start_date, tz = 'UTC'), as.POSIXct(end_date, tz = 'UTC'),
        dhours(1))%>%
    as.data.frame() %>%
    rename('date' = '.')
  
  data <- hourly
  title <- 'hourly'

    }
  
  if (unit == 'day') {
          #define date column as all days
    date_col <- 
    seq(as.POSIXct(start_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      as.POSIXct(end_date, format = "%Y-%m-%d", na = "NA", tz = 'UTC'),
      ddays(1)) %>%
    as.data.frame() %>%
    rename('date' = '.')
    
    data <- daily
    title <- 'daily'

  }
  
  #make title just home number if simple == TRUE
  title <- if_else(simple == TRUE, hm,
                                    paste(hm, title, metric))
   ##Plot data
    ##tryCatch to bypass plots that dont have data
    tryCatch(data %>%
               filter(home == hm, room == rm) %>%
               
               ##instead, define hour col between first and last date
               ##of the home/room specific data?
               right_join(date_col) %>%
               select(metric) %>%
               ggacf(lag.max = lag.max,
                     main = title),
             
             ##return NULL if there is an error
             ##due to no data for a home or room
             error = function(e) NULL)


  
}




###########

acf.grid.nomiss <- function(hms, rm, metric, lag.max,
                                start_date, end_date, unit,
                     ncol = 5) {
  
  
  plots <- lapply(hms, acf.plot.nomiss,
                  rm = rm, metric = metric,
                  lag.max = lag.max,
                  start_date = start_date, end_date = end_date,
                  unit = unit, simple = TRUE)
  
  
  ##omit NULL values (from homes or rooms without valid data)
  plots <- plots[!sapply(plots, is.null)]
  
  if (unit == 'hour') {title <- 'hourly'}
    if (unit == 'day') {title <- 'daily'}

  
  do.call('grid.arrange', c(plots, top = paste(rm, title, metric,
                                               as.POSIXct(start_date,
                                                          format = "%Y-%m-%d",
                                                          tz = 'UTC'), 'to',
                                               as.POSIXct(end_date,
                                                          format = "%Y-%m-%d",
                                                          tz = 'UTC')),
                            ncol = ncol))
  
}




#define list of homes for analysis
home_num <- home.list(1:16)






# test variables
metric <- 'pm25'
rm <- 'living'
lag.max <- 7
hms <- home.list(c(1:7))
unit <- 'day'


```

# Autocorrelation Raw Values

```{r autocorrelation, message= FALSE}



################Avoid claculation of AC if there are missing values



 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')





# hourly
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')


```


# Autocorrelation Log-Transformed Values

```{r autocorrelation_log, message= FALSE}



################Avoid claculation of AC if there are missing values



 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')




# hourly log-transformed
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'hour')


# daily log-transformed
# pm25
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

# voc
acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')


# ####separate homes by sELA
# ##low_sELA homes
# acf.grid.nomiss(hms = low_sela, rm = 'living',
#                     metric = 'pm25',  lag.max = 48,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')
# 
# ##high sELA homes
# acf.grid.nomiss(hms = high_sela, rm = 'living',
#                     metric = 'pm25',  lag.max = 48,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')

```



# Autocorrelation for different time lengths

  * (subset of homes for comparibility)

```{r autocorrelation_time_lengths, message = FALSE}

# deinfe list of homes that have available data for given data range
 homes_available <- 
  sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour') %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)


 

#make temporary definitions of data to preserve it for the rest of code chunks
hourly_original <- hourly
daily_original <- daily


#filter out certain homes

hourly <- hourly_original %>%
  filter(home %in% homes_available)

daily <- daily_original %>%
  filter(home %in% homes_available)



# ## hourly bewteen two date ranges
# 
# a<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-15 00:00:00',
#                 unit = 'hour')
# 
# b<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-12-7 00:00:00',
#                 unit = 'hour')
# 
# c<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-11-30 00:00:00',
#                 unit = 'hour')
# 
# d<- acf.grid.nomiss(hms = home_num, rm = 'living',
#                     metric = 'pm25_ihs',  lag.max = 24,
#                     start_date = '2020-11-15 00:00:00',
#                     end_date = '2020-11-23 00:00:00',
#                 unit = 'hour')
# 
# plots <- list(a,b, c, d)
# 
# do.call('grid.arrange', c(plots, ncol = 2))




## daily bewteen two date ranges
# PM2.5

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-11-30 00:00:00',
                unit = 'day')
plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


## daily bewteen two date ranges
# VOC

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-12-15 00:00:00',
                unit = 'day')

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = '2020-11-15 00:00:00',
                    end_date = '2020-11-30 00:00:00',
                unit = 'day')
plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))




#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original



```


# Autocorrelation for different time periods

  * (subset of homes for comparibility)

```{r autocorrelation_seasonal, message = FALSE}

 sapply(home_num, count.missing, rm = 'living',
       '2020-9-15 00:00:00',
       '2020-10-15 00:00:00',
       unit = 'hour')

 sapply(home_num, count.missing, rm = 'living',
       '2020-11-15 00:00:00',
       '2020-12-15 00:00:00',
       unit = 'hour')
 
 start_1 <- '2020-11-15 00:00:00'
  end_1 <- '2020-12-15 00:00:00'
   start_2 <- '2020-9-15 00:00:00'
  end_2 <- '2020-10-15 00:00:00'

 
  
  
#make temporary definitions of data to preserve it for the rest of code chunks
hourly_original <- hourly
daily_original <- daily
  
  
  

######################### hourly

unit_temp <- 'hour'

#deinfe list of homes that have available data for given data range
 homes_available1 <-
  sapply(home_num, count.missing, rm = 'living',
       start_1, end_1,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)

 #match with available homes from another date range
 homes_available <- sapply(home_num, count.missing, rm = 'living',
       start_2, end_2,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0 & home %in% homes_available1) %>%
  pull(home)



#filter out certain homes

hourly <- hourly_original %>%
  filter(home %in% homes_available)





## hourly bewteen two date ranges

# PM
a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 24,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


# VOC

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 24,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))

#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original







######################### daily

unit_temp <- 'day'

#deinfe list of homes that have available data for given data range
 homes_available1 <- 
  sapply(home_num, count.missing, rm = 'living',
       start_1, end_1,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0) %>%
  pull(home)
 
 #match with available homes from another date range
 homes_available <- sapply(home_num, count.missing, rm = 'living',
       start_2, end_2,
       unit = unit_temp) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  setNames(c('home', 'missing')) %>%
  filter( missing == 0 & home %in% homes_available1) %>%
  pull(home)
 
 

#filter out certain homes

daily <- daily_original %>%
  filter(home %in% homes_available)





## daily bewteen two date ranges
# PM2.5

a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'pm25_ihs',  lag.max = 7,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))


# VOC
a<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = start_1,
                    end_date = end_1,
                unit = unit_temp)

b<- acf.grid.nomiss(hms = home_num, rm = 'living',
                    metric = 'voc_ihs',  lag.max = 7,
                    start_date = start_2,
                    end_date = end_2,
                unit = unit_temp)


plots <- list(a,b)

do.call('grid.arrange', c(plots, ncol = 2))

#reset hourly and daily data to original
hourly <- hourly_original
daily <- daily_original



```

# Ensure that the starting point does not affect autocorrelation

```{r starting_point, echo = TRUE}

# define 2 sequences, one that is translated by a value of pi/12
x1 <- seq(0,4*pi, pi/4)
x2 <- seq(pi/4,4*pi + pi/4, pi/4)

# take sine of both sequences
# simulating if we started calculating acf for a time series at 3am as opposed to 12 am
# or tuesday as opposed to wednesday (assuming the pattern repeats)
y1 <- sin(x1)
y2 <- sin(x2)

acf1<- acf(y1)
acf2<-acf(y2)




```
