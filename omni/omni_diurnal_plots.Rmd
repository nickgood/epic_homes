---
title: "omni_diurnal"
author: "Andrew Purgiel"
date: "7/22/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

---

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra)
```

```{r data_import}
omni_hourly <- read_rds('./csv_created/omni_hourly_calibrated.rds')

```

# only use data up to June 2021
```{r censor_date}
omni_hourly <- omni_hourly %>% filter(datehour<ymd_hms('2021-06-01 00:00:00'))


```



```{r functions_misc}


 # function to extract a legend from one plot for use in whole plot grid
 # reference: https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots
 g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}
 
 # misc------------------------------------------------

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


#function to make density plot of variable x (a column)
dens.plot <- function(data, x) {
  
ggdensity(pull(data, all_of(x)), 
          main = paste("Density plot of", x),
          xlab = x)
}



#Mean and sd functions to ignore NA values
mean_NA <- function(x, na.rm = na.rm) {
  mean(x, na.rm = TRUE)}

sd_NA <- function(x, na.rm = na.rm) {
  sd(x, na.rm = TRUE)}

#Function to only display 3 significant figures (for tables)
signif3 <- function(x){
  signif(x, digits = 3)
}



#Function found online for geometric mean to use for plots
#webpage: https://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in
#adjusted so zeros are not ignored, just added one, to all values and subtract at end
#adjusted "length" to ignore values that are NA


gm = function(x, na.rm=TRUE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(any(x == 0, na.rm = TRUE)){
    exp(sum(log(x+1), na.rm=na.rm) / length(x[!is.na(x)]))-1
  }
  else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x[!is.na(x)]))
  }
}



#make low and high sd "interval" functions
low.sd = function(x){
  mean_NA(x)-sd_NA(x)
}

high.sd = function(x){
  mean_NA(x)+sd_NA(x)
}


#create function for standard error
std.error = function(x, na.rm=TRUE){
  sd_NA(x)/sqrt(length(x[!is.na(x)]))
}

##make low and high 95% conf interval (default 95%)
low.conf = function(x){
  gm(x)-1.96*std.error(x)
}

high.conf = function(x){
  gm(x)+1.96*std.error(x)
}

# make function to label metric names with subscripts
labeller.metrics <- as_labeller(c('pm25'='PM[2.5]', 'voc'="TVOC",
                                  'co2' = 'CO[2]', 'temp' = 'Temperature'),
                           default = label_parsed)

# make function to label metric names with subscripts and seasons
labeller.all <- as_labeller(c(
  'pm25'='PM[2.5]', 'voc'="TVOC",
  'co2' = 'CO[2]', 'temp' = 'Temperature',
  'ac' = 'AC', 'shoulder' = 'Shoulder', 'heat' = 'Heat',
  'kitchen' = 'Kitchen', 'living' = 'Living', 'bedroom' = 'Bedroom',
  'outdoor' = 'Outdoor', 'garage'= 'Garage'
  ), default = label_parsed)

    
```


```{r define_variables}

##For plot labeling pruposes
xsmall <- 6
small <- 15
medium <- 20
large <- 26
line_size <- 0.5
max_point_size <- 0.75

# define y-limits for metrics (for time series plots)
pm25_lim <- c(0,30)
voc_lim <- c(0,600)
co2_lim <- c(0,2500)
temp_lim <- c(0,25)
humid_lim <- c(0,60)
lux_lim <- c(0,1000)
spl_a_lim <- c(40,70)

# define y-limits for metrics (for difference of means plots)
pm25_diff_lim <- c(-10,10)
voc_diff_lim <- c(-400,700)
co2_diff_lim <- c(-600,1000)
temp_diff_lim <- c(-5,3.5)
humid_diff_lim <- c(-9,9)
lux_diff_lim <- c(-500,750)
pm25_diff_lim <- c(-10,10)
spl_a_diff_lim <- c(-9,9)

## for zoom:
#   pm25_lim <- c(0,40)
# voc_lim <- c(0,1000)
# co2_lim <- c(0,1500)
# temp_lim <- c(15,25)
# humid_lim <- c(20,60)
# lux_lim <- c(0,500)
# spl_a_lim <- c(40,70)




homes_all <- home.list(c(1:16))
homes_no5 <- home.list(c(1:4, 6:16))
metrics_all <- c('pm25', 'voc', 'co2', 'temp','humid', 'lux', 'spl_a')
locations_indoor <- c('living', 'bedroom', 'kitchen')
locations_all <- c(locations_indoor, 'outdoor', 'garage')
periods_all <- c('hour', 'day', 'month')


# color blind pallette
# check http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
cbbPalette <- c('black' = "#000000",
                'light_orange' = "#E69F00",
                'light_blue' = "#56B4E9",
                'green' = "#009E73",
                'yellow' = "#F0E442",
                'dark_blue' = "#0072B2",
                'dark_orange' = "#D55E00",
                'purple' = "#CC79A7"
                )
# define colors for room-comparisons
room_colors <- c(cbbPalette['green'],
                   cbbPalette['purple'],
                   cbbPalette['light_orange']
                   )%>% unname()

room_breaks <- locations_indoor

# define colors for energy clusters
energy_colors <- c(cbbPalette['light_blue'],
                   cbbPalette['green'],
                   cbbPalette['dark_orange'],
                   cbbPalette['black'])%>% unname()

energy_breaks <- c('ac', 'shoulder', 'heat', 'overall')
energy_labels <- c('Summer', 'Shoulder', 'Winter', 'Entire Period')

```


```{r functions_diurnal}
##Function to make table for plots of real time OMNI data
##averaged by hour of day, weekday, month, or a combination
diurnal.table <- function(data,
                       start_date = "1900-01-13 00:00:00",
                       end_date = "9999-08-13 00:00:00",
                       groupers = NULL, # vector of variables to group by
                       # arithmetic mean if FALSE, geometric if TRUE
                       locations = locations_indoor,
                       error = 'conf',
                       geometric = FALSE 
                       ) {
  
  #use start and end date to define timespan during which to use data
  a <- data %>%
    filter(datehour > ymd_hms(start_date) &
             datehour < ymd_hms(end_date) &
             location %in% locations_indoor)
  
  #if geo is FALSE (default), use arithmetic mean and standard deviation
  #to plot line and error bars respectively
  #if geo is TRUE, use geometric mean and 95% conf interval
  #to plot line and error bars respectively
  if(geometric == FALSE){
    mean.val <- function(x) {mean(x, na.rm = TRUE)}

  } else if(geometric == TRUE){
    mean.val <- function(x) {gm(x)}

  }
  
  if(error == 'conf'){
    high.val <- function(x) {
      mean.val(x)+1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
    low.val <- function(x) {
      mean.val(x)-1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
} else if(error == 'sd'){
    high.val <- function(x) mean.val(x)+sd(x, na.rm = TRUE)
    low.val <- function(x) mean.val(x)-sd(x, na.rm = TRUE)
 }
  
  # average and plot values by hour of day
    a <- a %>%
      mutate(hour = hour(datehour))
    
    a <- a %>%
      group_by_at(.vars= c('hour', groupers)) %>%
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val)) %>%
      left_join(
        a %>%
          group_by_at(.vars= c('hour', groupers)) %>%
      summarize(n = n(), .groups = 'drop'),
      by = c('hour', groupers),
      )%>%
      mutate(hour = as.numeric(hour))
    
  

  return(a)

}

    # plot without labels and such
    plot.diurnal <- function(dat, metric, err_ribbon = TRUE) {
      
      # define upper y-limit for plot based on metric
      y_range <- case_when(
        metric == 'pm25' ~ pm25_lim,
        metric == 'voc' ~ voc_lim,
        metric == 'co2' ~ co2_lim,
        metric == 'temp' ~ temp_lim,
        metric == 'humid' ~ humid_lim,
        metric == 'lux' ~ lux_lim,
        metric == 'spl_a' ~ spl_a_lim)
      
      ggplot(dat, aes(x = hour, y = get(paste0(metric, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(metric, '_high.val')),
                        ymin = get(paste0(metric, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = metric,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)
      
    }

    


```

### Diurnal plot for overall sampling period pooled homes, pooled rooms
```{r, fig.height=3, fig.width=5}
err_ribbon <- TRUE

# make diurnal plots
    a <- diurnal.table(omni_hourly)

#pm25------------
 met <- 'pm25'

 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
     
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)
        
   
      
# voc--------------   
      met <- 'voc'
      
 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
 
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size) 
# co2--------------   
      met <- 'co2'
      
 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
 
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size) 
      
```


### Diurnal plot for seasons pooled homes, disagg rooms
```{r, fig.height=3, fig.width=10.5}
err_ribbon <- TRUE

# make diurnal plots
    a <- diurnal.table(omni_hourly, groupers = 'location')

#pm25------------
 met <- 'pm25'

 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
     
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)+
        facet_wrap(vars(location))
        
   
      
# voc--------------   
      met <- 'voc'
      
 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
 
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size) +
        facet_wrap(vars(location))
# co2--------------   
      met <- 'co2'
      
 y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim,
        met == 'co2' ~ co2_lim)
 
      ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val'))
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size) +
        facet_wrap(vars(location))
      
      
```


### Diurnal plot by seasons defined by behaviors
```{r}
err_ribbon <- TRUE



clust.diurn <- function(met, data){
  
  y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim)
  
  
        ggplot(data, aes(x = hour, y = get(paste0(met, '_mean.val')),
                    fill = energy_cluster, color = energy_cluster
))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)+
        annotate('text', x=Inf, y = Inf, hjust = 1, vjust = 1,
                 label = '*Unclassified Days and\nGroup 1 Homes omitted')+
        scale_fill_manual(
          breaks = energy_breaks,
          values = energy_colors,
          labels = energy_labels,
          aesthetics = c('fill', 'color')
        )+
          facet_wrap(vars(energy_cluster))

}
      


```


### Group 2 and 3 Homes

```{r}

# make diurnal plots
    a <- diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2', 'tier3')),
                       groupers = 'energy_cluster') %>%
      bind_rows(
        diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2', 'tier3')))%>%
                        mutate(energy_cluster = 'overall')
      )

clust.diurn('pm25', a)

clust.diurn('voc', a)

clust.diurn('co2', a)
```

### Group 2 Homes

```{r}

# make diurnal plots
    a <- diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2')),
                       groupers = 'energy_cluster') %>%
      bind_rows(
        diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2')))%>%
                        mutate(energy_cluster = 'overall')
      )

clust.diurn('pm25', a)

clust.diurn('voc', a)

clust.diurn('co2', a)
```


### Group 3 Homes

```{r}

# make diurnal plots
    a <- diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier3')),
                       groupers = 'energy_cluster') %>%
      bind_rows(
        diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier3')))%>%
                        mutate(energy_cluster = 'overall')
      )

clust.diurn('pm25', a)

clust.diurn('voc', a)

clust.diurn('co2', a)
```

### by season disaggregated by home
```{r}

# make diurnal plots
    a <- diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2', 'tier3')),
                       groupers = c('energy_cluster', 'home')) %>%
      bind_rows(
        diurnal.table(omni_hourly %>%
                         filter(!is.na(energy_cluster) &
                                  home_type %in% c('tier2', 'tier3')),
                      groupers = c( 'home'))%>%
                        mutate(energy_cluster = 'overall')
      )

met <- 'co2'

  
        ggplot(a, aes(x = hour, y = get(paste0(met, '_mean.val')),
                    fill = home, color = home
))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        # coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)+
        annotate('text', x=Inf, y = Inf, hjust = 1, vjust = 1,
                 label = '*Unclassified Days and\nGroup 1 Homes omitted')+
          facet_wrap(vars(energy_cluster))    

```



### Diurnal plot by seasons define by month
```{r}
err_ribbon <- TRUE

a <- omni_hourly %>%
  filter(!is.na(energy_cluster) &
           home_type %in% c('tier2', 'tier3'))%>%
  mutate(month = months(datehour, abbreviate = TRUE))%>%
  mutate(
         energy_cluster = case_when(
           month %in% month.abb[c(12,1,2)] ~ "winter",
           month %in% month.abb[c(3,4,5)] ~ "spring",
           month %in% month.abb[c(6,7,8)] ~ "summer",
           month %in% month.abb[c(9,10,11)] ~ "fall"
         )
  )

# make diurnal plots
    a <- diurnal.table(a, groupers = 'energy_cluster')
      # bind_rows(
      #   diurnal.table(a)%>%
      #     mutate(energy_cluster = 'overall')
      # )


month.diurn <- function(met, data){
  
   y_range <- case_when(
        met == 'pm25' ~ pm25_lim,
        met == 'voc' ~ voc_lim)
   
  ggplot(data, aes(x = hour, y = get(paste0(met, '_mean.val')),
                    fill = energy_cluster, color = energy_cluster
))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = get(paste0(met, '_high.val')),
                        ymin = get(paste0(met, '_low.val'))
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(y = met,
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size)+
        annotate('text', x=Inf, y = Inf, hjust = 1, vjust = 1,
                 label = '*Unclassified Days and\nGroup 1 Homes omitted')+
        scale_fill_manual(
          breaks = c('summer', 'fall', 'winter', 'spring', 'overall'),
          values = c(cbbPalette['light_blue'],
                   cbbPalette['green'],
                   cbbPalette['dark_orange'],
                   cbbPalette['dark_blue'],
                   cbbPalette['black'])%>% unname(),
          labels = c('Summer', 'Fall', 'Winter', 'Spring', 'Entire Period'),
          aesthetics = c('fill', 'color')
        )+
          facet_wrap(vars(energy_cluster))
}

#pm25------------
month.diurn('pm25', a)

# month.diurn('pm25', a%>%filter(energy_cluster == 'winter'))
# month.diurn('pm25', a%>%filter(energy_cluster == 'fall'))
# month.diurn('pm25', a%>%filter(energy_cluster == 'spring'))
# month.diurn('pm25', a%>%filter(energy_cluster == 'summer'))


# voc--------------   
     
month.diurn('voc', a)

# month.diurn('voc', a%>%filter(energy_cluster == 'winter'))
# month.diurn('voc', a%>%filter(energy_cluster == 'fall'))
# month.diurn('voc', a%>%filter(energy_cluster == 'spring'))
# month.diurn('voc', a%>%filter(energy_cluster == 'summer'))
```


# Multiple metrics in one plot

##overall monitoring period
```{r functions_diurnal_rooms}
##Function to make table for plots of real time OMNI data
##averaged by hour of day, weekday, month, or a combination
diurnal.table <- function(data,
                          met,
                       start_date = "1900-01-13 00:00:00",
                       end_date = "9999-08-13 00:00:00",
                       groupers = NULL, # vector of variables to group by
                       # arithmetic mean if FALSE, geometric if TRUE
                       locations = locations_all,
                       error = 'conf',
                       geometric = FALSE 
                       ) {
  
  #use start and end date to define timespan during which to use data
  a <- data %>%
    filter(datehour > ymd_hms(start_date) &
             datehour < ymd_hms(end_date) &
             location %in% locations) %>%
    select(datehour, home, location, all_of(met), energy_cluster)
  
  #if geo is FALSE (default), use arithmetic mean and standard deviation
  #to plot line and error bars respectively
  #if geo is TRUE, use geometric mean and 95% conf interval
  #to plot line and error bars respectively
  if(geometric == FALSE){
    mean.val <- function(x) {mean(x, na.rm = TRUE)}

  } else if(geometric == TRUE){
    mean.val <- function(x) {gm(x)}

  }
  
  if(error == 'conf'){
    high.val <- function(x) {
      mean.val(x)+1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
    low.val <- function(x) {
      mean.val(x)-1.96*sd(x, na.rm = TRUE)/sqrt(length(x[!is.na(x)]))
    }
} else if(error == 'sd'){
    high.val <- function(x) mean.val(x)+sd(x, na.rm = TRUE)
    low.val <- function(x) mean.val(x)-sd(x, na.rm = TRUE)
 }
  
  # average and plot values by hour of day
    a <- a %>%
      mutate(hour = hour(datehour))
    
    a <- a %>%
      group_by_at(.vars= c('hour', groupers)) %>%
      summarize_if(is.numeric, list(mean.val = mean.val,
                                    low.val = low.val,
                                    high.val = high.val)) %>%
      left_join(
        a %>%
          group_by_at(.vars= c('hour', groupers)) %>%
      summarize(n = n(), .groups = 'drop'),
      by = c('hour', groupers),
      )%>%
      mutate(hour = as.numeric(hour)
             ) %>% 
      mutate(metric = met)
             
    
  

  return(a)

}

# test <- diurnal.table(omni_hourly, 'pm25', groupers = c('location'))


    # plot 
    plot.diurnal <- function(dat, err_ribbon = TRUE) {

      # make a dummy df in which to define limits for each metric
limit_df <- dat %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

    
      ggplot(dat, aes(x = hour, y = mean.val
                      # color = home
                      ))+
        geom_line( size = line_size)+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = high.val,
                        ymin = low.val
                        # fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day',
          size= 'Home-Hours of Data')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0),
                           labels = c('12am', '6am', '12pm', '6pm'))+
        theme_bw()+
        # coord_cartesian(ylim = y_range)+
        theme(
          plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall)
      )+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n))+
        scale_size_area(max_size = max_point_size,
                        )+
        facet_grid(rows = vars(metric), cols = vars(location),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
        theme(
      strip.background = element_rect(fill = NA, color = NA),
      strip.placement = 'outside'
              )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))
      
      }



```

```{r plots_diurnal_rooms, fig.height=5, fig.width=8}


# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(omni_hourly, x_metric, groupers = 'location')
}
) %>% bind_rows()

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom',
                                            'garage', 'outdoor'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal(a)


```

##disaggregated by season
```{r functions_diurnal_seasons}


    # plot without labels and such
    plot.diurnal.season <- function(dat, n_homes, err_ribbon = TRUE) {

      
      # make a dummy df in which to define limits for each metric
limit_df <- dat %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0,
         max = case_when(
           metric == 'pm25' ~ 30,
           metric == 'voc' ~ 600,
           metric == 'co2' ~ 1000
         )
         ) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


      ggplot(dat, aes(x = hour, y = mean.val
                      # color = home
                      ))+
        geom_line( size = line_size,
                      aes(color = energy_cluster, fill = energy_cluster)
                   )+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = high.val,
                        ymin = low.val,
                      fill = energy_cluster
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day',
          fill = 'Behavior-Defined Season',
          color = 'Behavior-Defined Season',
          size = 'Home-Hours of Data'
          )+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0),
                           labels = c('12am', '6am', '12pm','6pm'))+
        theme_bw()+
        # coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n,
                      color = energy_cluster, fill = energy_cluster
                 ))+
        scale_size_area(max_size = max_point_size)+
        facet_wrap(vars(metric),
                   scales = 'free_y',
                   labeller = labeller.all
                   )+
                scale_fill_manual(
          breaks = energy_breaks,
          values = energy_colors,
          labels = energy_labels,
          aesthetics = c('fill', 'color')
        )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))+
        #ensure seaons legend on top
        guides(
    fill = guide_legend(order = 1),
        color = guide_legend(order = 1),
    size = guide_legend(order = 2)
  )+
        labs(tag = paste('*n homes =', n_homes) )+
      theme(
        plot.tag.position = c(.1,0.02),
        strip.background = element_rect(fill = NA, color = NA)
        )
    }


```

### Group 2 and 3
```{r plots_diurnal_seasons, fig.height=2.5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier2', 'tier3'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'energy_cluster')
}
) %>%
  bind_rows()
# %>%
#   # bind with data not disagreggated by season
#   bind_rows(
#     map(c('pm25', 'voc', 'co2'), function(x_metric){
#   diurnal.table(a, x_metric)
# }
# )  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
#   )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season(a)



```


### Group 2
```{r plots_diurnal_seasons, fig.height=2.5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier2'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'energy_cluster')
}
) %>%
  bind_rows()
# %>%
#   # bind with data not disagreggated by season
#   bind_rows(
#     map(c('pm25', 'voc', 'co2'), function(x_metric){
#   diurnal.table(a, x_metric)
# }
# )  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
#   )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season(a, n_homes = 5)



```


### Group 3
```{r plots_diurnal_seasons, fig.height=2.5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier3'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'energy_cluster')
}
)%>%
bind_rows()
# %>%
#   # bind with data not disagreggated by season
#   bind_rows(
#     map(c('pm25', 'voc', 'co2'), function(x_metric){
#   diurnal.table(a, x_metric)
# }
# )  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
#   )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season(a, n_homes = 5)



```


##disaggregated by season and home
```{r functions_diurnal_seasons_homes}


    # plot without labels and such
    plot.diurnal.season.home <- function(dat, err_ribbon = TRUE) {

      # make a dummy df in which to define limits for each metric
limit_df <- dat %>%
  group_by(metric) %>%
  summarize(max = max(mean.val))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')

    
      ggplot(dat, aes(x = hour, y = mean.val
                      # color = home
                      ))+
        geom_line( size = line_size,
                      aes(color = home)
                   )+
        ##geom_errorbar(aes(ymax = pm25_high.val, ymin = pm25_low.val))+ ##bars instead?
        geom_ribbon(aes(ymax = high.val,
                        ymin = low.val,
                      fill = home
                        ),
                    alpha = if_else(err_ribbon == TRUE, 0.2, 0), color = NA)+
        labs(
          y = 'Average Value',
             x = 'Hour of Day')+
        scale_x_continuous(limits = c(0,24),
                           breaks = c(0,6,12,18),
                           expand = c(0,0))+
        theme_bw()+
        # coord_cartesian(ylim = y_range)+
        theme(plot.title = element_blank(),
      axis.text.x = element_text(size = xsmall))+
        # make point size proportional to # of obs, with 0 obs = size 0
  geom_point(aes(size = n,
color = home
))+
        scale_size_area(max_size = max_point_size)+
        facet_grid(rows = vars(metric), cols = vars(energy_cluster),
                   scales = 'free_y')+

        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 15, y = limits))
    }


```

### Group 2 and 3
```{r plots_diurnal_seasons_homes, fig.height=5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier2', 'tier3'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = c('energy_cluster', 'home'))
}
) %>%
  bind_rows() %>%
  # bind with data not disagreggated by season
  bind_rows(
    map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'home')
}
)  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
  )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season.home(a)



```


### Group 2
```{r plots_diurnal_seasons_homes, fig.height=5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier2'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = c('energy_cluster', 'home'))
}
) %>%
  bind_rows() %>%
  # bind with data not disagreggated by season
  bind_rows(
    map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'home')
}
)  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
  )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season.home(a)



```


### Group 3
```{r plots_diurnal_seasons_homes, fig.height=5, fig.width=8}

a <- omni_hourly %>% filter(home_type %in% c('tier3'))

# make dataframe that includes all metrics    
a <- map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = c('energy_cluster', 'home'))
}
) %>%
  bind_rows() %>%
  # bind with data not disagreggated by season
  bind_rows(
    map(c('pm25', 'voc', 'co2'), function(x_metric){
  diurnal.table(a, x_metric, groupers = 'home')
}
)  %>% bind_rows() %>% mutate(energy_cluster = 'overall') 
  )

# change order of metrics for plotting
a$energy_cluster <- factor(a$energy_cluster, levels = c('overall', 'ac', 'shoulder',
                                            'heat'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2'))

# plot
plot.diurnal.season.home(a)



```

