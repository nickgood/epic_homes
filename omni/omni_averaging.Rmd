---
title: "Average Value Plots"
author: "Andrew Purgiel"
date: "7/22/2021"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.width = 10, fig.height = 3,
  cache = FALSE)
```

---

```{r libraries}
library(dplyr)
library(purrr)
library(tidyr)
library(openair)
library(ggplot2)
library(readr)
library(googlesheets4)
library(lubridate)
library(gridExtra)
# library(tidymodels) # to discretize data for histogram
library(arules) # to discretize data for histogram
```

```{r data_import}
# daily date without missing dates
omni_daily <- read_rds('./csv_created/omni_daily_calibrated.rds')

omni_hourly <- read_rds('./csv_created/omni_hourly_calibrated.rds')

# home type dataframe
home_type_df <- read_csv('../sense/csv_created_sense/home_type_df.csv')

# acf significant lag data
lag_df <- read_csv('./csv_created/lag_summary.csv')



```

# only use data up to June 2021
# and rename noise variable
```{r censor_date}
omni_daily <- omni_daily %>% filter(dateday<ymd_hms('2021-06-01 00:00:00'))%>%
  rename('date' = dateday)

omni_hourly <- omni_hourly %>% filter(datehour<ymd_hms('2021-06-01 00:00:00'))%>%
  rename('date' = datehour)
```


```{r functions_misc}

 # misc------------------------------------------------

##Define a char vector of home numbers using a number vector,
##ex: x <- home.list(c(1:15)) for homes 1-15
threedig <- function(x) {
  if (nchar(x) == 1) {a <- paste0('00', x)
  return(a)
  }
  
  if (nchar(x) == 2) {a<- paste0('0', x)
  return(a)
  }
  else return(a)
}

home.list <- function(x) sapply(x, threedig)


 # function to extract a legend from one plot for use in whole plot grid
 # reference: https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots
 g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}
 



#Mean and sd functions to ignore NA values
mean_NA <- function(x, na.rm = na.rm) {
  mean(x, na.rm = TRUE)}

sd_NA <- function(x, na.rm = na.rm) {
  sd(x, na.rm = TRUE)}

#Function to only display 3 significant figures (for tables)
signif3 <- function(x){
  signif(x, digits = 3)
}



#Function found online for geometric mean to use for plots
#webpage: https://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in
#adjusted so zeros are not ignored, just added one, to all values and subtract at end
#adjusted "length" to ignore values that are NA


gm = function(x, na.rm=TRUE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(any(x == 0, na.rm = TRUE)){
    exp(sum(log(x+1), na.rm=na.rm) / length(x[!is.na(x)]))-1
  }
  else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x[!is.na(x)]))
  }
}



#make low and high sd "interval" functions
low.sd = function(x){
  mean_NA(x)-sd_NA(x)
}

high.sd = function(x){
  mean_NA(x)+sd_NA(x)
}


#create function for standard error
std.error = function(x, na.rm=TRUE){
  sd_NA(x)/sqrt(length(x[!is.na(x)]))
}

##make low and high 95% conf interval (default 95%)
low.conf = function(x){
  gm(x)-1.96*std.error(x)
}

high.conf = function(x){
  gm(x)+1.96*std.error(x)
}





# labeller

# make function to label metric names with subscripts and seasons
labeller.all <- as_labeller(c(
  'pm25'='PM[2.5]', 'voc'="TVOC",
  'co2' = 'CO[2]', 'temp' = 'Temperature', 'humid' = 'Humidity',
  'lux' = 'Light', 'spl_a' = 'Noise',
  'ac' = 'Cooling', 'shoulder' = 'Shoulder', 'heat' = 'Heating',
  'kitchen' = 'Kitchen', 'living' = 'Living', 'bedroom' = 'Bedroom',
  'outdoor' = 'Outdoor', 'garage'= 'Garage'
  ), default = label_parsed)
  
```



# define variables
```{r define_variables}

##For plot labeling pruposes
xsmall <- 6
small <- 15
medium <- 20
large <- 26

# define y-limits for metrics (for time series plots)
pm25_lim <- c(0,60)
voc_lim <- c(0,1500)
co2_lim <- c(0,2500)
temp_lim <- c(0,25)
humid_lim <- c(0,60)
lux_lim <- c(0,1000)
noise_lim <- c(40,70)

# define y-limits for metrics (for difference of means plots)
pm25_diff_lim <- c(-23,20)
voc_diff_lim <- c(-300,500)
co2_diff_lim <- c(-600,1250)
temp_diff_lim <- c(-5,3.5)
humid_diff_lim <- c(-9,9)
lux_diff_lim <- c(-500,750)
noise_diff_lim <- c(-9,9)

## for zoom:
#   pm25_lim <- c(0,40)
# voc_lim <- c(0,1000)
# co2_lim <- c(0,1500)
# temp_lim <- c(15,25)
# humid_lim <- c(20,60)
# lux_lim <- c(0,500)
# spl_a_lim <- c(40,70)




homes_all <- home.list(c(1:16))
homes_no5 <- home.list(c(1:4, 6:16))
homes_tier1 <- home_type_df %>% filter(home_type == 'tier1') %>% pull(home)
homes_tier2 <- home_type_df %>% filter(home_type == 'tier2') %>% pull(home)
homes_tier3 <- home_type_df %>% filter(home_type == 'tier3') %>% pull(home)

metrics_all <- c('pm25', 'voc', 'co2', 'temp','humid', 'lux', 'spl_a')
locations_indoor <- c('living', 'bedroom', 'kitchen')



# color blind pallette
# check http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
cbbPalette <- c('black' = "#000000",
                'light_orange' = "#E69F00",
                'light_blue' = "#56B4E9",
                'green' = "#009E73",
                'yellow' = "#F0E442",
                'dark_blue' = "#0072B2",
                'dark_orange' = "#D55E00",
                'purple' = "#CC79A7"
                )
# define colors for room-comparisons
room_colors <- c(cbbPalette['green'],
                   cbbPalette['purple'],
                   cbbPalette['light_orange']
                   )%>% unname()

room_breaks <- locations_indoor

room_labels <- c('Living', 'Bedroom', 'Kitchen')

# define colors for energy clusters
energy_colors <- c(cbbPalette['light_blue'],
                   cbbPalette['green'],
                   cbbPalette['dark_orange'],
                   cbbPalette['black'])%>% unname()

energy_breaks <- c('ac', 'shoulder', 'heat', 'overall')
energy_labels <- c('Cooling', 'Shoulder', 'Heating', 'Entire Period')


# define lag periods
lag_pm25 <-lag_df %>% filter(energy_cluster == 'total', metric == 'pm25') %>%
  pull(median) %>% round()
lag_voc <-lag_df %>% filter(energy_cluster == 'total', metric == 'voc') %>%
  pull(median)%>% round()
lag_co2 <- lag_df %>% filter(energy_cluster == 'total', metric == 'co2') %>%
  pull(median)%>% round()
lag_temp <- lag_df %>% filter(energy_cluster == 'total', metric == 'temp') %>%
  pull(median)%>% round()
lag_humid <- lag_df %>% filter(energy_cluster == 'total', metric == 'humid') %>%
  pull(median)%>% round()
lag_lux <- lag_df %>% filter(energy_cluster == 'total', metric == 'lux') %>%
  pull(median)%>% round()
lag_spl_a <- lag_df %>% filter(energy_cluster == 'total', metric == 'spl_a') %>%
  pull(median)%>% round()
```


# make averaging function
```{r}

# function-----------
avg.data <- function(data  = omni_daily, met){
  days <- case_when(
    met == 'pm25' ~ lag_pm25,
    met == 'voc' ~ lag_voc,
    met == 'co2' ~ lag_co2,
    met == 'temp' ~ lag_temp,
    met == 'humid' ~ lag_humid,
    met == 'lux' ~ lag_lux,
    met == 'spl_a' ~ lag_spl_a
    )
  
  data %>%
    select(date, home, location, all_of(met), energy_cluster) %>%
          mutate(date_avg = floor_date(date, unit = paste(days, 'days'))) %>%
       drop_na(all_of(met))%>% # drop NA values to ensure n is accurate
          group_by(home, location, energy_cluster, date_avg) %>%
        # summarise_at(vars(all_of(met)), list(mean = mean, sd = sd), na.rm = TRUE) %>%
    summarise_at(vars(all_of(met)), list(~mean(., na.rm = TRUE), ~sd(., na.rm = TRUE),
                                  ~n())) %>%
    ungroup() %>%
    mutate(metric = met, avg_period_days = days)
}
#######

#test one home----------
# test <- avg.data(met = 'pm25')


####

```


# make data for all metrics avg'd by time lag
```{r}
data_avg <- 
  map(
    metrics_all, function(x_metric) { 
      avg.data(data = omni_daily, met = x_metric)
    }
  )%>% bind_rows()

```


# boxplots by season, by room, pooled homes

## All homes
```{r, fig.width=8, fig.height=5.5}
# only indoor, all Homes, some metrics --------
a <- data_avg %>%
  filter(location %in% locations_indoor) %>%
  filter(metric %in% c('pm25', 'voc', 'co2', 'temp')) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)])

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))
a$energy_cluster <- factor(a$energy_cluster, levels = c('ac', 'shoulder', 'heat'))


    # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(mean))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


ggplot(a,aes(x = location, y = mean))+
  geom_violin()+
  geom_boxplot(width = 0.2, outlier.shape = NA)+
        facet_grid(rows = vars(metric), cols = vars(energy_cluster),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
  scale_x_discrete(
    limits = room_breaks,
    labels = room_labels
  )+
  theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
                strip.placement = 'outside',
          panel.grid.major.x = element_blank()
          )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'kitchen', y = limits))+
  xlab('Sampling Location')+
  ylab('IEQ Indicator Value')
  

###







```

## group 2 Homes
```{r, fig.width=5.5, fig.height=5.5}
# only indoor, Group 2 Homes, some metrics --------
a <- data_avg %>%
  filter(location %in% locations_indoor) %>%
  filter(metric %in% c('pm25', 'voc', 'co2', 'temp')) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier2)

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))
a$energy_cluster <- factor(a$energy_cluster, levels = c('ac', 'shoulder', 'heat'))


    # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(mean))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


ggplot(a,aes(x = location, y = mean))+
  geom_violin()+
  geom_boxplot(width = 0.2, outlier.shape = NA)+
        facet_grid(rows = vars(metric), cols = vars(energy_cluster),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
  scale_x_discrete(
    limits = room_breaks,
    labels = room_labels
  )+
  theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
                strip.placement = 'outside',
          panel.grid.major.x = element_blank()
          )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'kitchen', y = limits))+
  xlab('Sampling Location')+
  ylab('IEQ Indicator Value\nin Group 2 Homes')
  

###


```

## Group 3 Homes
```{r, fig.width=8, fig.height=5.5}

# only indoor, Group 3 Homes, some metrics --------
a <- data_avg %>%
  filter(location %in% locations_indoor) %>%
  filter(metric %in% c('pm25', 'voc', 'co2', 'temp')) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier3)

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))
a$energy_cluster <- factor(a$energy_cluster, levels = c('ac', 'shoulder', 'heat'))


    # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(mean))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


ggplot(a,aes(x = location, y = mean))+
  geom_violin()+
  geom_boxplot(width = 0.2, outlier.shape = NA)+
        facet_grid(rows = vars(metric), cols = vars(energy_cluster),
                   scales = 'free_y',
                   labeller = labeller.all,
                   switch = 'y')+
  scale_x_discrete(
    limits = room_breaks,
    labels = room_labels
  )+
  theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
                strip.placement = 'outside',
          panel.grid.major.x = element_blank()
          )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'kitchen', y = limits))+
  xlab('Sampling Location')+
  ylab('IEQ Indicator Value\nin Group 3 Homes')
  

###


```



# by season, pooled rooms and homes

# group 2 Homes
```{r, fig.width=5.5, fig.height=2}
# only indoor, Group 2 Homes, some metrics --------
a <- data_avg %>%
  filter(location %in% locations_indoor) %>%
  filter(metric %in% c('pm25', 'voc', 'co2', 'temp')) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier2)

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))
a$energy_cluster <- factor(a$energy_cluster, levels = c('ac', 'shoulder', 'heat'))


    # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(mean))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


ggplot(a,aes(x = energy_cluster, y = mean))+
  geom_violin()+
  geom_boxplot(width = 0.2, outlier.shape = NA)+
        facet_wrap(vars(metric), nrow = 1,   scales = 'free_y',
                   labeller = labeller.all)+
  scale_x_discrete(
    limits = energy_breaks[c(2:3)],
    labels = energy_labels[c(2:3)]
  )+
  theme_bw()+
       # guides(col = guide_legend(ncol = 2))+ #split up legend
          ##for extra space between facets
    theme(
          strip.background =element_blank(),
          panel.grid.major.x = element_blank()
          )+
        # use dummy df to define limits for each metric
        geom_blank(data = limit_df, aes(x = 'heat', y = limits))+
  xlab('Season')+
  ylab('IEQ Indicator Value\nin Group 2 Homes')
  

###


```

# Group 3 Homes
```{r, fig.width=8, fig.height=2}

# only indoor, Group 3 Homes, some metrics --------
a <- data_avg %>%
  filter(location %in% locations_indoor) %>%
  filter(metric %in% c('pm25', 'voc', 'co2', 'temp')) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier3)

# change order of metrics for plotting
a$location <- factor(a$location, levels = c('kitchen', 'living', 'bedroom'))
a$metric <- factor(a$metric, levels = c('pm25', 'voc', 'co2', 'temp'))
a$energy_cluster <- factor(a$energy_cluster, levels = c('ac', 'shoulder', 'heat'))


    # make a dummy df in which to define limits for each metric
limit_df <- a %>%
  group_by(metric) %>%
  summarize(max = max(mean))%>%
  mutate(min = 0) %>%
        pivot_longer(cols = c(max, min), names_to = 'side', values_to = 'limits')


ggplot(a,aes(x = energy_cluster, y = mean))+
  geom_violin()+
  geom_boxplot(width = 0.08, outlier.shape = NA)+
        facet_wrap(vars(metric), nrow = 1,   scales = 'free_y',
                   labeller = labeller.all)+
  scale_x_discrete(
    limits = energy_breaks[c(1:3)],
    labels = energy_labels[c(1:3)]
  )+
  theme_bw()+
  # guides(col = guide_legend(ncol = 2))+ #split up legend
  ##for extra space between facets
  theme(
    strip.background =element_blank(),
    panel.grid.major.x = element_blank(),
    strip.text = element_text(size = small -3),
    axis.text.y = element_text(size = small -3),
    axis.text.x = element_text(size = small -4),
    axis.title = element_text(size = small -3)
    )+
  # use dummy df to define limits for each metric
  geom_blank(data = limit_df, aes(x = 'heat', y = limits))+
  xlab('Season')+
  ylab('IEQ Indicator Value\nin Group 3 Homes')
  

###


```




# Make Data for hourly by season, by room, pooled homes


## group 2 Homes
```{r}
# by home --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier2) %>%
  pivot_longer(c(humid:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by(location, metric, energy_cluster, home) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_hours = n(),
             .groups = 'drop')

group2_home <- a %>%
  select(energy_cluster, metric, home, everything(.)) %>%
  arrange(energy_cluster, metric, home)


write_csv(group2_home, './csv_created/averages/group2_home_avg.csv')


# summary --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier2) %>%
  pivot_longer(c(humid:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by(location, metric, energy_cluster) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_home_hours = n(),
             .groups = 'drop')

group2 <- a %>%
  select(energy_cluster, metric, everything(.)) %>%
  arrange(energy_cluster, metric)


write_csv(group2, './csv_created/averages/group2_avg.csv')


```

## Group 3 Homes
```{r}

# by home --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier3) %>%
  pivot_longer(c(humid:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by(location, metric, energy_cluster, home) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_hours = n(),
             .groups = 'drop')

group3_home <- a %>%
  select(energy_cluster, metric, home, everything(.)) %>%
  arrange(energy_cluster, metric, home)


write_csv(group3_home, './csv_created/averages/group3_home_avg.csv')


# summary --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier3) %>%
  pivot_longer(c(humid:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by(location, metric, energy_cluster) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_home_hours = n(),
             .groups = 'drop')

group3 <- a %>%
  select(energy_cluster, metric, everything(.)) %>%
  arrange(energy_cluster, metric)


write_csv(group3, './csv_created/averages/group3_avg.csv')

```



# Make Data for hourly  homes, pooled rooms


## group 2 Homes (clustered)
```{r}
# by home --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier2) %>%
  pivot_longer(c(co2:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by( metric, energy_cluster, home) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_room_hours = n(),
             .groups = 'drop')

b <- a %>%
  select(energy_cluster, metric, home, everything(.)) %>%
  arrange(energy_cluster, metric, home)


write_csv(b, './csv_created/averages/group2-home-pooled_rooms-avg.csv')


# summary --------
summary <- b %>%
  group_by(metric, energy_cluster) %>%
  summarise(mean_homes = mean(avg),
            sd_homes = sd(avg),
            n_homes = n(), .groups = 'drop') %>%
  select(energy_cluster, everything(.))%>%
  arrange(energy_cluster)



write_csv(summary, './csv_created/averages/group2_avg_summary.csv')


```

## Group 3 Homes (clustered)
```{r}
# by home --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  filter(energy_cluster %in% energy_breaks[c(1:3)]) %>%
  filter(home %in% homes_tier3) %>%
  pivot_longer(c(co2:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by( metric, energy_cluster, home) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_room_hours = n(),
             .groups = 'drop')

b <- a %>%
  select(energy_cluster, metric, home, everything(.)) %>%
  arrange(energy_cluster, metric, home)


write_csv(b, './csv_created/averages/group3-home-pooled_rooms-avg.csv')


# summary --------
summary <- b %>%
  group_by(metric, energy_cluster) %>%
  summarise(mean_homes = mean(avg),
            sd_homes = sd(avg),
            n_homes = n(), .groups = 'drop') %>%
  select(energy_cluster, everything(.))%>%
  arrange(energy_cluster)



write_csv(summary, './csv_created/averages/group3_avg_summary.csv')
```




## all homes (unclustered)
```{r}
# by home --------
a <- omni_hourly %>%
  filter(location %in% locations_indoor) %>%
  pivot_longer(c(co2:temp), values_to = 'value', names_to = 'metric')%>%
    filter(metric %in% c('pm25', 'voc', 'co2', 'temp', 'humid', 'lux', 'spl_a')) %>%
  group_by( metric, home) %>%
  summarise( avg = mean(value, na.rm = TRUE),
             sd = sd(value, na.rm = TRUE),
             n_room_hours = n(),
             .groups = 'drop')

b <- a %>%
  select( metric, home, everything(.)) %>%
  arrange( metric, home)


write_csv(b, './csv_created/averages/all_home-pooled_rooms-avg.csv')


# summary --------
summary <- b %>%
  group_by(metric) %>%
  summarise(mean_homes = mean(avg),
            sd_homes = sd(avg),
            n_homes = n(), .groups = 'drop') %>%
  select( everything(.))



write_csv(summary, './csv_created/averages/all_home_avg_summary.csv')
```

